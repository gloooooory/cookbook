= Dart Cookbook
:author: Shailen Tuli
:encoding: UTF-8

== Web UI

=== Using Dart variables and expressions inside HTML

==== Problem

You want to inject the value of Dart identifiers and expressions in your
markup.

==== Solution

Put Dart identifier and expressions within `{{ }}`.

The Web UI framework evaluate the code inside `{{  }}` and injects the result
into the markup.

Begin with defining some variables and functions in a file (main.dart):

--------------------------------------------------------------------------------
import 'package:web_ui/web_ui.dart';

var x = 32;
var y = 3;

num div(x, y) => x / y;
num intDiv(x, y) => x ~/ y;

void main() {}

--------------------------------------------------------------------------------

Then, interpolate those variables and functions into your markup (`main.html`).
You can interpolate idenfiers, functions (with arguments), and you can call
methods:

--------------------------------------------------------------------------------
<!DOCTYPE html>

<html>
  <body>
      
    <div>
      There are two ways to divide numbers in Dart. Assume:
      <ul>
        <li>x = {{ x }}</li>
        <li>y = {{ y }}</li>
      </ul>
    </div>
    
    <div>   
      Integer division:
      <ul>
        <li>x ~/ y = {{ intDiv(x,y) }}</li>
      </ul>
    </div>
      
    <div>
      Double division:
      <ul>
        <li>x / y = {{ div(x,y) }}</li>
      </ul>
    </div>
    
    <div>
      You can write the number {{ x }} in a bunch of ways:
      <ul>
        <li>In binary: {{ x.toRadixString(2) }}</li>
        <li>In octal: {{ x.toRadixString(8) }}</li>
        <li>In hexadecimal: {{ x.toRadixString(16) }}</li>
      </ul>
    </div>
    
    <script type="application/dart" src="main.dart"></script>
  </body>
</html>
--------------------------------------------------------------------------------


=== Creating a one-way data binding

==== Problem

You want to sync up a variable and its display. Every time the variable's
value changes, you want its display to auto-magically change without having to
do any DOM manipulation.

==== Solution

Add an `@observable` declaration right before you define a variable. This create
a binding between that variable and its display in the UI.

--------------------------------------------------------------------------------
@observable 
var myVar;
--------------------------------------------------------------------------------

You can then use the variable in your markup. The `@observable` declaration
ensures that every time the variable's value changes, the UI updates
automatically.

==== Discussion

Imagine you have a collection of movie quotes that you would like to display
on a page. You don't want to show all the quotes at once, but prefer to roll
them out one by one every couple of seconds in a slideshow fashion.

Since only a single quote displays at a time, the markup for that is pretty
straightforward (`main.html`):

--------------------------------------------------------------------------------
<!DOCTYPE html>

<html>
  <body>
    <div><em>{{ quote.quote }}</em> - {{ quote.saidBy }}</div>
  
    <script type="application/dart" src="main.dart"></script>
  </body>
</html>
--------------------------------------------------------------------------------

The Dart code (`main.dart`) is responsible for setting up the logic for
picking one quote from the quote collection. The variable storing the quote
being displayed _is made observable_, and its value is refreshed every two seconds:

--------------------------------------------------------------------------------
import 'package:web_ui/web_ui.dart';
import 'dart:async';

class Quote {
  String quote, saidBy; 
  Quote(this.quote, this.saidBy);
}

// MAGIC!!!
@observable 
var quote;
  
void main() {
   List<Quote> quotes = [
     new Quote('This agression will not stand, man.', 'The Dude'),
     new Quote('You are entering a world of pain', 'Walter'),
     new Quote('The rug really tied the room together.', 'The Dude'),
     new Quote('Mark it zero, dude', 'Walter')
     ];
    
   var i = 0;
   quote = quotes[i];
   
   // Cycle through the quotes, picking a new quote every couple of seconds.
   new Timer.periodic(new Duration(milliseconds:2000), (_) {
     i = (i == quotes.length - 1) ? 0 : i + 1;
     quote = quotes[i];
   });
 }
--------------------------------------------------------------------------------

When a new quote is selected, the UI updates to display it. There is no need
for a page refresh, and you don't have to worry about any DOM manipulation. 


=== Creating a two way data binding

==== Problem

You want to sync a variable and its display in the UI so that when the variable
changes, its display updates, and when the variable's display changes, its value
updates.

==== Solution

Create a two-way binding between an object and its display. This is a two-step
process.

Step 1: Make the object observable:

--------------------------------------------------------------------------------
@observable
var someObject = someValue;
--------------------------------------------------------------------------------

This creates a one-way binding between the object and its display in the UI.
If the object's value changes, the UI updates accordingly. 

Step 2: Bind an HTML element to the object you just declared observable using
the `bind-property="object"` syntax (where `property` is some associated property
in the HTML element).

If the Dart object is a String (possibly represented in the UI with a text
input), the associated `property` is 'value'. Use `bind-value` to create the
binding:

--------------------------------------------------------------------------------
<input type="text" bind-value="someObject">
--------------------------------------------------------------------------------

If the Dart object is a boolean (possibly represented in the UI with a
checkbox), the associated `property` is 'checked'. Use `bind-checked` to create
the binding:

--------------------------------------------------------------------------------
<input type="checkbox" bind-checked="someObject">
--------------------------------------------------------------------------------

This second step makes the binding bi-directional: now, changes made in the UI
reset the bound object's value.

==== Discussion

The short script below demonstrates the power of two-way data binding. 

A variable (`str`) is made observable, and given a default starting value.
A text input box is bound to this variable using the `bind-value` syntax
discussed above.

If you change the value in the input box, `str`s value changes.

If you then reset `str`'s value using the 'Reset` button provided, the
UI adjusts automatically.  

Here is the markup ('main.html'):


--------------------------------------------------------------------------------
<!DOCTYPE html>

<html>
  <body>
    <div>
      Input:
      <input type="text" bind-value="str" placeholder="type something here">
      <br>
      
      <p>The value of 'str' is: {{str}}</p>
      <br />
      <div>
        <input on-click="reset()" type='button' value="Reset 'str' value" />
      </div>
    </div>

    <script type="application/dart" src="main.dart"></script>
   </body>
</html>
--------------------------------------------------------------------------------

And here is the accompanying Dart code ('main.dart'):

--------------------------------------------------------------------------------
import 'package:web_ui/web_ui.dart';

var fact = 'Dart is fun!';

@observable
String str;
    
void reset() {
  str = fact;
}
    
main() {
  str = fact;
}
--------------------------------------------------------------------------------

=== Looping over a collection


==== Problem

You want to use a template to display each item in a collection.

==== Solution

To loop over a collection, use the iterate attribute within a template tag:

--------------------------------------------------------------------------------
<template iterate='item in collection'>
--------------------------------------------------------------------------------

==== Discussion

Consider the following Dart code that defines a collection of books:

--------------------------------------------------------------------------------
import "package:web_ui/web_ui.dart";

var books = [];

main() {
  books = [
    ["War and Peace", 20.99, 1013],
    ["Anna Karenina", 23.99, 1243],
    ["The Old Man and the Sea", 8.99, 78]
  ]; 
}
--------------------------------------------------------------------------------

Here is some code that loops over the books collection and prints out the
details of each book: 

--------------------------------------------------------------------------------
<!DOCTYPE html>

<html>
  <head>
  <style>
    ul {list-style: none; margin: 0; padding: 0px 10px 16px 0px}
    li {padding: 5px 10px 0 0;}
  </style>
</head>

<body>  
    <template iterate='book in books'>
      <ul>
        <li>Name: {{book[0]}}</li>
        <li>Price: {{book[1]}}</li>
        <li>Pages: {{book[2]}}</li>
      </ul>
    </template>
  
  <script type="application/dart" src='main.dart'></script>
</body>
</html>
--------------------------------------------------------------------------------

You can also express loops using attributes on any element. Here is the syntax
for doing that:

--------------------------------------------------------------------------------
<tbody template iterate='book in books'>
--------------------------------------------------------------------------------
  
Because <template> tags are not permitted within HTML tables, you must use
this syntax to use loops with table rows and cells. 

--------------------------------------------------------------------------------
<!DOCTYPE html>
<html lang="en">
<head>
  <style>
    td {padding-right: 25px;}
  </style>
</head>
<body>  
  <table>
    <tbody template iterate='book in books'>
      <tr template iterate='attribute in book'>
        <td>{{attribute}}</td>
      </tr>
    </tbody>
  </table>
  
  <script type="application/dart" src='main.dart'></script>
</body>
</html>
--------------------------------------------------------------------------------


=== Selectively activating parts of the UI

==== Problem

You want to conditionally display parts of a page. Maybe you want to start off
with only a small amount of content on a page, and display more content if
the user requests it.

==== Solution

Wrap a portion of the UI in a <template> tag, and instantiate the template
conditionally by using the following syntax:

--------------------------------------------------------------------------------
<template instantiate='if conditionalVariable'> 
--------------------------------------------------------------------------------

For this to work, you need to make the conditional variable observable:

--------------------------------------------------------------------------------
@observable
bool conditionalVariable = false;
--------------------------------------------------------------------------------

Then, set up the UI bindings to toggle the state of the conditional variable.
You can use a checkbox, and `bind-checked` to create the binding: 

--------------------------------------------------------------------------------
<input type="checkbox" bind-checked="conditionalVariable">
--------------------------------------------------------------------------------

If the checkbox is checked, the conditional variable becomes true, and the
conditional template activates.

==== Discussion

Shown below is code for displaying user records. The name of the user is
always displayed. The full user record is displayed only if the 'Show full
record' checkbox is checked.

The list of records and he conditional variable are defined in the Dart code
(`main.dart`):
 
--------------------------------------------------------------------------------
import 'package:web_ui/web_ui.dart';

class Record {
  String name, age, phone, email;
  
  Record(this.name, this.age, this.phone, this.email);
}

var records = [
    new Record('John Doe', '34', '212-555-1234', 'john@jd.com'),
    new Record('Mario Lark', '33', '510-454-4545', 'ml@ml.com'),
    new Record('Paula Ho', '37', '617-555-4321', 'paula@ph.org')
  ];
 
@observable
bool showFullRecord = false;

void main() {}
--------------------------------------------------------------------------------

The HTML uses a loop to iterate over the list of records, displaying the full
record only if the checkbox is checked:

--------------------------------------------------------------------------------
<!DOCTYPE html>

<html>
  <head>
    <style>
      ul {list-style-position: inside; padding-left: 10px}
    </style>
  </head>
  <body> 
  
    <div>
      <input type="checkbox" bind-checked="showFullRecord" />Show full record
      <br>
    </div>
  
    <div>
      <template iterate='record in records'>
        <ul>
          <li>{{record.name}}   
            <template instantiate='if showFullRecord'>   
              <ul>
                <li>{{record.age}}</li>
                <li>{{record.phone}}</li>
                <li>{{record.email}}</li>
              </ul>
            </template>
          </li> 
        </ul> 
      </template>
    </div>

  <script type="application/dart" src="main.dart"></script>
</body>
</html>
--------------------------------------------------------------------------------


=== Binding element attributes to variables

==== Problem

You want to dynamically set the value of an element attribute.

==== Solution

Create a binding between that attribute and a Dart variable. When the
variable's value changes, the attribute's value updates automatically.

==== Discussion

The code below demonstrates how to dynamically modify an element's class
attribute in order affect the element's style properties (`dart.html`):

--------------------------------------------------------------------------------
<!DOCTYPE html>

<html>
  <head>
    <style>
      .small  {font-size: .95em;}
      .normal {font-size: 1.1em;}
      .large  {font-size: 1.25em;}
    </style>
  </head>
  
  <body> 
   <div>
     <h3>Set font size:</h3>
     <input type="radio" value='small' bind-value="fontSizeClass">Small
     <input type="radio" value='normal' bind-value="fontSizeClass">Normal
     <input type="radio" value='large' bind-value="fontSizeClass">Large
  </div>
  <hr>
    
  <div class="{{fontSizeClass}}">
    
    <p>Key Lime Pie ingredients:</p>
    
    <ul>
      <li>1 (9 inch) prepared graham cracker crust</li>
      <li>3 cups sweetened condensed milk</li>
      <li>1/2 cup sour cream</li>
      <li>3/4 cup key lime juice</li>
    </ul>
  </div>
    
    <script type="application/dart" src="main.dart"></script>
  </body>
</html>
--------------------------------------------------------------------------------

Here is the `main.dart` file:

--------------------------------------------------------------------------------
import 'package:web_ui/web_ui.dart';

@observable
String fontSizeClass='normal';

void main() {}
--------------------------------------------------------------------------------

The main div element's class is stored in a variable:

--------------------------------------------------------------------------------
<div class="{{fontSizeClass}}">
--------------------------------------------------------------------------------

We declare that variable observable: when it changes, the div's class also
changes:

--------------------------------------------------------------------------------
@observable
String fontSizeClass='normal';
--------------------------------------------------------------------------------

We create a binding between the `fontSizeClass` variable and some radio buttons
using `bind-value` syntax:

--------------------------------------------------------------------------------
<input type="radio" value='small' bind-value="fontSizeClass">Small
...
--------------------------------------------------------------------------------

When the user selects a button, the button's value becomes the value of 
`fontSizeClass`, which then becomes the value of the div element's class
attribute.

===== Having multiple classes

This script is simple. The user can alter the class of an element and
manipulate the font size of that element. The script can be easily extended to
give the element multiple classes.

Web UI templates support several ways of notating multiple classes. You can use
multiple variables:

--------------------------------------------------------------------------------
<div class="{{Class1}} {{Class2}}"></div>
--------------------------------------------------------------------------------

Or, use a list:

--------------------------------------------------------------------------------
<div class="{{classes}}"></div>
--------------------------------------------------------------------------------

Or, combine the classes in a string:

--------------------------------------------------------------------------------
<div class="{{classesAsString}}"></div>
--------------------------------------------------------------------------------


=== Binding complex objects

==== Problem

You've defined a class, created objects of that class, and written code in the
UI to display those objects.

You find that it takes an awful lot of effort to keep those objects synced up
with the UI, and you find your code littered with @observable declarations.


==== Solution

Make an entire class observable. This will make each attribute of every
instance of that class observable.

--------------------------------------------------------------------------------
@observable
class Point() {
  num x, y;
  Point(this.x, this.y);
}
--------------------------------------------------------------------------------

==== Discussion

The example below shows code for storing information about a Person. We define a
Person class, make it observable, and create a couple of Person objects
(`main.dart`):

--------------------------------------------------------------------------------
import 'package:web_ui/web_ui.dart';

@observable
class Person {
  String firstName;
  String lastName;
  String dateOfBirth;
  
  Person(this.firstName, this.lastName, this.dateOfBirth);
}

Person person;

main() { 
  person = new Person('Jon',  'Smith', '1999/09/06');
}
--------------------------------------------------------------------------------

In `main.html` we display each Person object along with a form to edit the
Person record. We bind the input fields in the form to the Person object using
`bind-value` syntax:

--------------------------------------------------------------------------------
<!DOCTYPE html>

<html>
<body> 
  <div> 
    <template iterate='person in persons'>
      
      <p>
        {{ person.firstName }}, {{ person.lastName }}, {{ person.dateOfBirth }}
      </p>
      
      <p>
        First Name: <input type="text" bind-value="person.firstName">
        Last Name: <input type="text" bind-value="person.lastName">
        Date of birth: <input type="text" bind-value="person.dateOfBirth"> 
      </p>
      <hr>
    </template>
  </div>

  <script type="application/dart" src="main.dart"></script>
</body>
</html>

--------------------------------------------------------------------------------

Because of the data-binding created between every Person instance and the
UI, changing the value in any input box modifies the corresponding object
attribute.


=== Binding complex objects that use composition

==== Problem

You want to create a binding for complex objects that are made up of other
complex objects.

==== Solution

Declare both the composing and the composed classes observable:

--------------------------------------------------------------------------------
@observable
class Composer {
  num x, y;
  Composed composed;

  Composer(this.x, this.y, this.composed);
}

@observable
class Composed {
  num a, b;
  ...
}
--------------------------------------------------------------------------------

This makes every instance of the composing class observable. The composed
attribute is accessible like any other object attribute:

--------------------------------------------------------------------------------
composer.x;
composer.y;
composer.composed.a;
composer.composed.b;
--------------------------------------------------------------------------------

==== Discussion

The following program models a Person object. A Person has a first name, a
last name, a date of birth, and a Passport (`main.dart`):

--------------------------------------------------------------------------------
import 'package:web_ui/web_ui.dart';

@observable
class Person {
  String firstName;
  String lastName;
  String dateOfBirth;
  Passport passport;
  
  Person(this.firstName, this.lastName, this.dateOfBirth, this.passport);
}

@observable
class Passport {
  String number, dateIssued, placeIssued, expiresOn;
  Passport(this.number, this.dateIssued, this.placeIssued, this.expiresOn);
}

Person person;

main() { 
  person = new Person('Jon',  'Smith', '1999/09/06',
      new Passport('RN4455009', '2012/11/08', 'New York, NY', '2022/11/08'));
}

--------------------------------------------------------------------------------

The UI displays the Person record, as well as a form for editing that record.
Because we made the Passport class observable, we can edit the composed Passport
object through the UI:

--------------------------------------------------------------------------------
<!DOCTYPE html>

<html>
<head>
  <style>
    td, th {border: 1px solid black; margin: 2px; padding: 4px; width: 200px}
  </style>
</head>
<body> 
  <h3>Person record</h3>
  <table>  
    <tr>
      <th>First Name</th>
      <th>Last Name</th>
      <th>Date of Birth</th>
      <th>Passport Number</th>
      <th>Date Issued</th>
      <th>Place Issued</th>
      <th>Expires</th>
    </tr>
    
    <tr>
      <td>{{ person.firstName }}</td>
      <td>{{ person.lastName }}</td>
      <td>{{ person.dateOfBirth }}</td>
      
      <td>{{ person.passport.number }}</td>
      <td>{{ person.passport.dateIssued }}</td>
      <td>{{ person.passport.placeIssued }}</td>
      <td>{{ person.passport.expiresOn }}</td>
    </tr>
  </table>
  
  <h3>Edit record</h3>
  First Name: <input type="text" bind-value="person.firstName"><br>
  Last Name: <input type="text" bind-value="person.lastName"><br>
  Last Name: <input type="text" bind-value="person.dateOfBirth"><br>
  
  Passport Number: <input type="text" bind-value="person.passport.number"><br>
  Date issued: <input type="text" bind-value="person.passport.dateIssued"><br>
  Place issued: <input type="text" bind-value="person.passport.placeIssued"><br>
  Expires: <input type="text" bind-value="person.passport.expiresOn"><br>
 
  <script type="application/dart" src="main.dart"></script>
</body>
</html>

--------------------------------------------------------------------------------

=== Partially binding complex objects

==== Problem

You want every instance of a class to be observable, but don't want to make
every attribute of the instance observable.

==== Solution

Don't place an @observable declaration before the class definition. Instead,
place the @observable declaration before attributes that you want to make
observable. Attributes not preceded by the @observable declaration 
remain unaffected:

--------------------------------------------------------------------------------
@observable
class Point{
  num x;

  @observable
  num y;

  Point(this.x, this.y);
}
--------------------------------------------------------------------------------

==== Discussion

The example below models a User object. A User has three fields, a username,
an email address, and a tagline. You want only the username and tagline to be
observable:

--------------------------------------------------------------------------------
import 'package:web_ui/web_ui.dart';

class User {
  
  @observable
  String username;

  String email;
  
  @observable
  String tagline;
  
  User(this.username, this.email, this.tagline);
}
  
User user;

void main() {
  user = new User(
    'uber-dartisan', 
    'uber-dartisan@dartisans.com',
    'Knowing all there is to know about Dart'
  );  
}
--------------------------------------------------------------------------------

The `main.html` file displays the User record as well as a form for editing the
record. Editing the username or the tagline in the form immediately changes the
corresponding attributes in the record.

--------------------------------------------------------------------------------
<!DOCTYPE html>

<html> 
  <head>
    <style>
      td, th {border: 1px solid black; margin: 2px; padding: 4px; width: 200px}
    </style>
  </head>
  <body>   
    <table>
      <tr>
        <th>Username</th>
        <!-- <th>Email</th> -->
        <th>Tagline</th>
      </tr>
      <tr>
        <td>{{user.username}}</td>
        <!-- <td>{{user.email}}</td> -->
        <td>{{user.tagline}}</td>
    </table>
    
    <br>
    
    <div>
      Username: <input type='text' bind-value='user.username' /><br>
      <!-- Email: <input type='text' bind-value='user.email' /><br> -->
      Tagline: <input type='text' size=80 bind-value='user.tagline' /><br>
    </div>

    <script type="application/dart" src="main.dart"></script>
  </body>
</html>

--------------------------------------------------------------------------------

The email field has been commented out in the both the record display and the
form. Uncomment it and try to edit the user's email. Because this field was not
made observable, the record will not update:


=== Binding a Map object

==== Problem

You want to make a Map variable observable.

==== Solution

Use the `toObservable()` function provided by Web UI to make a Map observable.
You cannot use the conventional @observable declaration with a Map.


The `main.dart` file shown below defines a Map object and makes it observable:

--------------------------------------------------------------------------------
import 'package:web_ui/web_ui.dart';

var person;

main() { 
  person = toObservable({
    'firstName': 'Jon',  
    'lastName': 'Smith',
    'passport' : toObservable({
      'number': 'RN4455009', 
      'dateIssued': '2002/11/08', 
      'placeIssued': 'New York, NY'
    })}); 
}
--------------------------------------------------------------------------------

Note that the `passport` field of the Map is itself a Map. We made the nested
Map observable as well.

Here is the `main.html` file:

--------------------------------------------------------------------------------
<!DOCTYPE html>

<html>
  <body> 
    <div>
      <h3>Person record</h3>
      <p><em>First Name: </em> {{ person['firstName'] }}</p>
      <p><em>Last Name: </em> {{ person['lastName'] }}</p>
  
      <p><em>Address: </em> 
        {{person['address']['street']}}, 
        {{person['address']['city']}}, 
        {{person['address']['state']}}, 
        {{person['address']['zip']}}
      </p>  
      
    </div>
    
    <hr>
    
    <div>
      <h3>Edit record</h3>
      First Name: <input type="text" bind-value="person['firstName']"><br>
      Last Name: <input type="text" bind-value="person['lastName']"><br>
      
      Address Street: <input type="text" bind-value="person['address']['street']"><br>
      Address City: <input type="text" bind-value="person['address']['city']"><br>
      Address State: <input type="text" bind-value="person['address']['state']"><br>
      Address Zip: <input type="text" bind-value="person['address']['zip']"><br>      
    </div>

  <script type="application/dart" src="main.dart"></script>
  </body>
</html>
--------------------------------------------------------------------------------



