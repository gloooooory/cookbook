= Dart Cookbook
:author: Shailen Tuli
:encoding: UTF-8

== Testing


=== Run only the test you are working on with solo_test()

==== Problem

You want to run just a single test.  Maybe you want to run the test you are
currently working on and want to make that pass before running all your tests.
Or, maybe you want to explore a single failing test in the debugger, and don't
want to deal with the noise from the other tests. 

==== Solution

To isolate a test, change that test's `test()` call to `solo_test()`. Only the
`solo_test()` will run:

--------------------------------------------------------------------------------
import 'package:unittest/unittest.dart';

void main() {
  test('with y == 0', ()  => ... );
  solo_test('with y != 0', ()  => ... );
}

Program output:
  unittest-suite-wait-for-done
  PASS: with y != 0
  
  All 1 tests passed.
  unittest-suite-success
--------------------------------------------------------------------------------

If you mistakenly have more than one solo_test() then an exception will be
thrown. Only the first `solo_test()` will run:

--------------------------------------------------------------------------------
void main() {
  solo_test('with y == 0', ()  => ... );
  solo_test('with y != 0', ()  => ... );
}

Program output:
  unittest-suite-wait-for-done
  Exception: Only one test can be soloed right now.
  PASS: with y == 0
  
  All 1 tests passed.
  unittest-suite-success
--------------------------------------------------------------------------------

=== Filtering which tests are run using filterTests()

==== Problem

You want to run just a subset of all your tests. Maybe you've divided up
your tests carefully using `group()` and want to run the tests for one or more
group. Or perhaps you've been carefully placing certain keywords in your test
descriptions, and want to run only tests whose desciption contains a particluar
keyword.

==== Solution

Use `filterTests()`. This function takes a String or RegExp argument and
matches it against each test description.  If the description matches, the
test runs, otherwise, it doesnâ€™t.

Before you use `filterTests()`, you need to disable the automatic running of
tests. Do this by creating and initialize a minimal custom configuration:


--------------------------------------------------------------------------------
import "package:unittest/unittest.dart";
import "package:args/args.dart";

class FilterTests extends Configuration {
  get autoStart => false;
}

void useFilteredTests() {
  configure(new FilterTests());
  ensureInitialized(); // Initializes the test library.  
}
--------------------------------------------------------------------------------

Then, you can define tests, call `filteredTests()`, and run your tests using
`runTests()`:

--------------------------------------------------------------------------------
void main() {
  useFilteredTests();
  
  // your tests go here

  filterTests(someStringOrRegExp);
  runTests();
}
--------------------------------------------------------------------------------

Here is a complete example that demonstrates how `filterTests()` is used
to run just a subset of your tests. Run this code from the command line, and
provide an extra argument that gets passed to `filterTests()` (usage shown
below the code):

--------------------------------------------------------------------------------
import 'package:unittest/unittest.dart';
import 'package:args/args.dart';
import 'dart:io';

class FilterTests extends Configuration {
  get autoStart => false;
}

void useFilteredTests() {
  configure(new FilterTests());
  ensureInitialized();  
}

void main() {
  useFilteredTests();
  
  // Get the args from the command line.
  ArgParser argParser = new ArgParser();
  Options options = new Options();
  ArgResults results = argParser.parse(options.arguments);
  List<String> args = results.rest;

  test('one test', () => ... ); 
  test('crucial test', () => ... );
  test('another crucial test', =>  ...);

  group('case change', () {
    test('to upper', () => ... );
    test('to lower', () => ... );
  });

  if (!args.isEmpty) {
    filterTests(args[0]);
  }
  runTests();
}
--------------------------------------------------------------------------------

When the tests are run without any additional arguments, all 5 tests run:

--------------------------------------------------------------------------------
$ dart simple_test.dart

Program Output:
  unittest-suite-wait-for-done
  PASS: a test
  PASS: crucial test
  PASS: another crucial test
  PASS: case change to upper
  PASS: case change to lower

  All 5 tests passed.
  unittest-suite-success
--------------------------------------------------------------------------------

If 'crucial' is passed as an argument to `filterTests()`, only tests with
'crucial' in the description run:

--------------------------------------------------------------------------------
$ dart simple_test.dart another

Program Output:
  unittest-suite-wait-for-done
  PASS: crucial test
  PASS: another crucial test

  All 2 tests passed.
  unittest-suite-success
------------------------------------------------------------------------------

If 'case' is passed as an argument to `filterTests()`, only tests within the
'case change' group run:

--------------------------------------------------------------------------------
$ dart simple_test.dart case

Program Output:
  unittest-suite-wait-for-done
  PASS: case change to upper
  PASS: case change to lower
  
  All 2 tests passed.
  unittest-suite-success
--------------------------------------------------------------------------------


=== Using setUp() and tearDown() in your tests

==== Problem

You want initialization code to run before each test, and cleanup code to run
after each test, but want to avoid code duplication.

==== Solution

Within each `group()`, call `setUp()` for initialization and `tearDown()` for
cleanup. The function passed as an argument to `setUp()` runs before each
test, and the function passed as an argument to `tearDown()` runs
after each test.

===== setUp() example

Assume you have defined a Point class that contains several methods. You want
to test each method, and need a Point object in each test:

--------------------------------------------------------------------------------
void main() {
  group('test Point', () {
    test('toString', () {
      Point point = new Point(3, 4);
      ...
    });
    
    test('[](index)', () {
      Point point = new Point(3, 4); // REPETITIVE.
      ...
    });
  });
 }
}
--------------------------------------------------------------------------------

See all the repetition? Move the Point initialization to a `setUp()`. The
Point object will then become available in each test:

--------------------------------------------------------------------------------
void main() {
  group('test Point with setUp()', () {
    Point point;
    setUp(() {  
      point = new Point(3, 4);
    });

    test('toString',  () => expect(point.toString(), equals(...)));
    test('[](index)', () => expect(point[0], equals(...)));
  });
}
--------------------------------------------------------------------------------

Note that `point` is _instantiated before_ `setUp()`, and _initialized within_
`setUp()`. This makes `point` accessible in each test.

===== tearDown() example

Because `setUp()` simply creates a new Point before every test in the previous
example, there was no need for an explicit `tearDown()`.

Testing the `createFile()` function shown below does need a `tearDown()`:

--------------------------------------------------------------------------------
import 'package:unittest/unittest.dart';

import 'dart:io';


// Creates a file with some content in the given directory.
Path createFile(fileName, fileContent, directory) {
  ...
}
--------------------------------------------------------------------------------

Testing `createFile()` creates a file and a directory, and we have no
reason to retain either. After a test concludes, the file and directory should
be removed. We place the cleanup code for doing this within `tearDown()`.

--------------------------------------------------------------------------------
void main() {
  group('test createFile()', () {
    var tempDir;
    var fileName = 'a.txt';
    var fileContent = 'Content of a.txt';
    
    setUp(() {
       tempDir = new Directory('').createTempSync();
    });

    tearDown(() {
      if (tempDir.existsSync()) {
        tempDir.deleteSync(recursive: true);
      }
    });

    // Directory created before each test.
    // File created when createFile() is called during the test.
    // The directory and file are removed afte each test.
    test('creates the correct path', () => ...);
    test('throws with a non-existent directory', () => ...);
  });
}
--------------------------------------------------------------------------------

=== Testing synchronous exceptions

==== Problem

You want to test exceptions in your code. You want to know if some code
returns normally, or if it throws. Or you want to test that a specific error is
raised, and that the error message is correct. 

==== Solution

To test whether code throws, use the `throws` matcher: 

--------------------------------------------------------------------------------
expect(() => 10 ~/ 0, throws);
--------------------------------------------------------------------------------

To test that code runs without generating an exception, use the
`returnsNormally` matcher:

--------------------------------------------------------------------------------
expect(() => 10 ~/ 1, returnsNormally);
--------------------------------------------------------------------------------
  
You can test the error type:

--------------------------------------------------------------------------------
expect(() => throw new StateError('functions called in the wrong order'), 
        throwsStateError);
--------------------------------------------------------------------------------

The Unittest library provides matchers for commonly occuring exceptions and
errors:

--------------------------------------------------------------------------------
throwsException
throwsFormatException
throwsArgumentError
throwsRangeError
throwsNoSuchMethodError
throwsUnimplementedError
throwsStateError
throwsUnsupportedError
--------------------------------------------------------------------------------

You can also use `throwsA` with a predicate matcher to test the exception type:
  
--------------------------------------------------------------------------------
expect(() => 10 ~/ 0, 
  throwsA(predicate((e) => e is IntegerDivisionByZeroException)));
--------------------------------------------------------------------------------

Use `throwsA` to test a custom Exception:

--------------------------------------------------------------------------------
expect(() => throw new TooMuchCoffeeException(), 
  throwsA(predicate((e) => e is TooMuchCoffeeException)));
--------------------------------------------------------------------------------
  
You can test the error message:

--------------------------------------------------------------------------------
expect(() => throw new ArgumentError('bad argument'), 
  throwsA(predicate((e) => e.message == 'bad argument')));
--------------------------------------------------------------------------------

You can test the error type and the error message together:
  
--------------------------------------------------------------------------------
expect(() => throw new RangeError('out of range'), 
  throwsA(predicate((e) => (e is RangeError && e.message == 'out of range'))));
--------------------------------------------------------------------------------


=== Testing for float equality

==== Problem

You need to test that your float-returning function returns the right value,
but have been warned about the perils of comparing floats directly. So, how do
you test that your function is returning the right answer?

==== Solution 

Use the `closeTo()` matcher for testing approximate merical equality:

--------------------------------------------------------------------------------
closeTo(value, delta)
--------------------------------------------------------------------------------

This matcher checks if the number under test is within delta of some value,
and the test passes if it is.

Consider this code that computes the distance between two points: 

--------------------------------------------------------------------------------
Point point1 = new Point(-2, -3);
Point point2 = new Point(-4, 4);

print(point1.distanceTo(point2)); // 7.280109889280518.  
--------------------------------------------------------------------------------

Avoid direct comparisons when testing the `distanceTo()` method:

--------------------------------------------------------------------------------
expect(point1.distanceTo(point2), equals(7.280109889280518));
--------------------------------------------------------------------------------

Test for approximate equality:

--------------------------------------------------------------------------------
expect(point1.distanceTo(point2)), closeTo(7.28, .001)); 
--------------------------------------------------------------------------------


