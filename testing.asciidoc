= Dart Cookbook
:author: Shailen Tuli
:encoding: UTF-8

== Testing


=== Run only the test you are working on with solo_test()

==== Problem

You want to run just a single test.  Maybe you want to run the test you are
currently working on and want to make that pass before running all your tests.
Or, maybe you want to explore a single failing test in the debugger, and don't
want to deal with the noise from the other tests. 

==== Solution

To isolate a test, change that test's `test()` call to `solo_test()`. Only the
`solo_test()` will run:

--------------------------------------------------------------------------------
import 'package:unittest/unittest.dart';

void main() {
  test('with y == 0', ()  => ... );
  solo_test('with y != 0', ()  => ... );
}

Program output:
  unittest-suite-wait-for-done
  PASS: with y != 0
  
  All 1 tests passed.
  unittest-suite-success
--------------------------------------------------------------------------------

If you mistakenly have more than one solo_test() then an exception will be
thrown. Only the first `solo_test()` will run:

--------------------------------------------------------------------------------
void main() {
  solo_test('with y == 0', ()  => ... );
  solo_test('with y != 0', ()  => ... );
}

Program output:
  unittest-suite-wait-for-done
  Exception: Only one test can be soloed right now.
  PASS: with y == 0
  
  All 1 tests passed.
  unittest-suite-success
--------------------------------------------------------------------------------

=== Filtering which tests are run using filterTests()

==== Problem

You want to run just a subset of all your tests. Maybe you've divided up
your tests carefully using `group()` and want to run the tests for one or more
group. Or perhaps you've been carefully placing certain keywords in your test
descriptions, and want to run only tests whose desciption contains a particluar
keyword.

==== Solution

Use `filterTests()`. This function takes a String or RegExp argument and
matches it against each test description.  If the description matches, the
test runs, otherwise, it doesnâ€™t.

Before you use `filterTests()`, you need to disable the automatic running of
tests. Do this by creating and initialize a minimal custom configuration:


--------------------------------------------------------------------------------
import "package:unittest/unittest.dart";
import "package:args/args.dart";

class FilterTests extends Configuration {
  get autoStart => false;
}

void useFilteredTests() {
  configure(new FilterTests());
  ensureInitialized(); // Initializes the test library.  
}
--------------------------------------------------------------------------------

Then, you can define tests, call `filteredTests()`, and run your tests using
`runTests()`:

--------------------------------------------------------------------------------
void main() {
  useFilteredTests();
  
  // your tests go here

  filterTests(someStringOrRegExp);
  runTests();
}
--------------------------------------------------------------------------------

Here is a complete example that demonstrates how `filterTests()` is used
to run just a subset of your tests. Run this code from the command line, and
provide an extra argument that gets passed to `filterTests()` (usage shown
below the code):

--------------------------------------------------------------------------------
import 'package:unittest/unittest.dart';
import 'package:args/args.dart';
import 'dart:io';

class FilterTests extends Configuration {
  get autoStart => false;
}

void useFilteredTests() {
  configure(new FilterTests());
  ensureInitialized();  
}

void main() {
  useFilteredTests();
  
  // Get the args from the command line.
  ArgParser argParser = new ArgParser();
  Options options = new Options();
  ArgResults results = argParser.parse(options.arguments);
  List<String> args = results.rest;

  test('one test', () => ... ); 
  test('crucial test', () => ... );
  test('another crucial test', =>  ...);

  group('case change', () {
    test('to upper', () => ... );
    test('to lower', () => ... );
  });

  if (!args.isEmpty) {
    filterTests(args[0]);
  }
  runTests();
}
--------------------------------------------------------------------------------

When the tests are run without any additional arguments, all 5 tests run:

--------------------------------------------------------------------------------
$ dart simple_test.dart

Program Output:
  unittest-suite-wait-for-done
  PASS: a test
  PASS: crucial test
  PASS: another crucial test
  PASS: case change to upper
  PASS: case change to lower

  All 5 tests passed.
  unittest-suite-success
--------------------------------------------------------------------------------

If 'crucial' is passed as an argument to `filterTests()`, only tests with
'crucial' in the description run:

--------------------------------------------------------------------------------
$ dart simple_test.dart another

Program Output:
  unittest-suite-wait-for-done
  PASS: crucial test
  PASS: another crucial test

  All 2 tests passed.
  unittest-suite-success
------------------------------------------------------------------------------

If 'case' is passed as an argument to `filterTests()`, only tests within the
'case change' group run:

--------------------------------------------------------------------------------
$ dart simple_test.dart case

Program Output:
  unittest-suite-wait-for-done
  PASS: case change to upper
  PASS: case change to lower
  
  All 2 tests passed.
  unittest-suite-success
--------------------------------------------------------------------------------


=== Using setUp() and tearDown() in your tests

==== Problem

You want initialization code to run before each test, and cleanup code to run
after each test, but want to avoid code duplication.

==== Solution

Within each `group()`, call `setUp()` for initialization and `tearDown()` for
cleanup. The function passed as an argument to `setUp()` runs before each
test, and the function passed as an argument to `tearDown()` runs
after each test in the group.

===== setUp() example

Consider the following code for defining a Point:

--------------------------------------------------------------------------------
import 'package:unittest/unittest.dart';

class Point {
  num x, y;
  
  Point(this.x, this.y);
  
  String toString() => 'Point: x = $x, y = $y';
  
  num operator [](index) {
    if (index < 0 || index > 1) {
       throw new ArgumentError('only 0 and 1 are valid indices'); 
    }
    return (index == 0) ? x : y;
  }

  ...
}
--------------------------------------------------------------------------------

You want to test each method, and need a Point object in each test:

--------------------------------------------------------------------------------
void main() {
  group('test Point', () {
    test('toString', () {
      Point point = new Point(3, 4);
      expect(point.toString(), equals('Point: x = 3, y = 4'));
    });
    
    test('[](index)', () {
      Point point = new Point(3, 4); // REPETITIVE.
      expect(point[0], equals(3));
      expect(point[1], equals(4));
    });
  });
 }
}
--------------------------------------------------------------------------------

See all the repetition? Move the Point initialization to a `setUp()`:

--------------------------------------------------------------------------------
void main() {
  group('test Point with setUp()', () {
    Point point;
    setUp(() {  
      point = new Point(3, 4);
    });

    test('toString', () {
      expect(point.toString(), equals('Point: x = 3, y = 4'));
    });
    
    test('[](index)', () {
      expect(point[0], equals(3));
      expect(point[1], equals(4));
    });
  });
}
--------------------------------------------------------------------------------

Note that `point` is instantiated _before_ `setUp()`, and initialized within
`setUp()`. This way, `point` is available to each test.

===== tearDown() example

Because `setUp()` simply creates a new Point before every test in the previous
example, there was no need for an explicit `tearDown()`.

Testing the `createFile()` function defined below does need a `tearDown()`:

--------------------------------------------------------------------------------
import 'package:unittest/unittest.dart';

import 'dart:io';

Path createFile(fileName, fileContent, directory) {
  if  (!directory.existsSync()) {
    throw new ArgumentError('directory does not exist');
  }
  var path = new Path(directory.path).join(new Path(fileName));
  new File(path.toString()).writeAsStringSync(fileContent);
  return path;
}
--------------------------------------------------------------------------------

Testing `createFiles()` creates a file and a  directory that we have no
reason to retain. After a test concludes, the file and directory should
be removed. We place the cleanup code within `tearDown()`.

--------------------------------------------------------------------------------
void main() {
  group('test createFiles()', () {
    var tempDir;
    var fileName = 'a.txt';
    var fileContent = 'Content of a.txt';
    
    setUp(() {
       tempDir = new Directory('').createTempSync();
    });

    tearDown(() {
      if (tempDir.existsSync()) {
        tempDir.deleteSync(recursive: true);
      }
    });

    test('creates the correct path', () {
      var path = createFile(fileName, fileContent, tempDir);
      expect(new Path(tempDir.path).join(new Path(fileName)).toString(), 
          equals(path.toString()));
    });
    
    test('throws with a non-existent directory', () {
      tempDir.deleteSync(recursive: true);
      expect(() {
        var paths = createFile(fileName, fileContent, tempDir);
      }, throwsArgumentError);
    });
  });
}
--------------------------------------------------------------------------------

=== Testing synchronous exceptions

==== Problem

You want to test exceptions in your code. You want to know if some code
returns normally, or if it throws. Or you want to test that a specific error is
raised, or that the error message is correct. What support does the Unittest
library have for testing exceptions?

==== Solution

To test whether code throws, use the `throws` matcher: 

--------------------------------------------------------------------------------
expect(() => 10 ~/ 0, throws);
--------------------------------------------------------------------------------

To test that code runs without generating an exception, use the
`returnsNormally` matcher:

--------------------------------------------------------------------------------
expect(() => 10 ~/ 1, returnsNormally);
--------------------------------------------------------------------------------
  
You can test the error type:

--------------------------------------------------------------------------------
expect(() => throw new StateError('functions called in the wrong order'), 
        throwsStateError);
--------------------------------------------------------------------------------

The Unittest library provides matchers for commonly occuring exceptions and
errors:

--------------------------------------------------------------------------------
throwsException
throwsFormatException
throwsArgumentError
throwsRangeError
throwsNoSuchMethodError
throwsUnimplementedError
throwsStateError
throwsUnsupportedError
--------------------------------------------------------------------------------

You can also use `throwsA` with a predicate matcher to test the exception type:
  
--------------------------------------------------------------------------------
expect(() => 10 ~/ 0, 
  throwsA(predicate((e) => e is IntegerDivisionByZeroException)));
--------------------------------------------------------------------------------

Use `throwsA` to test a custom Exception:

--------------------------------------------------------------------------------
expect(() => throw new TooMuchCoffeeException(), 
  throwsA(predicate((e) => e is TooMuchCoffeeException)));
--------------------------------------------------------------------------------
  
You can test the error message:

--------------------------------------------------------------------------------
expect(() => throw new ArgumentError('bad argument'), 
  throwsA(predicate((e) => e.message == 'bad argument')));
--------------------------------------------------------------------------------

You can test the error type and the error message together:
  
--------------------------------------------------------------------------------
expect(() => throw new RangeError('out of range'), 
  throwsA(predicate((e) => (e is RangeError && e.message == 'out of range'))));
--------------------------------------------------------------------------------



