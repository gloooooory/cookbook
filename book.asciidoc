= Dart Cookbook
:author: Shailen Tuli
:encoding: UTF-8

== Strings

=== Concatenating strings

==== Problem

You want to concatenate strings in Dart. You tried using `+`, but that
resulted in an error.

==== Solution

Use adjacent string literals:

--------------------------------------------------
var fact = 'Dart'  'is' ' fun!'; // 'Dart is fun!'
--------------------------------------------------

==== Discussion

Adjacent literals work over multiple lines:

-------------------------
var fact = 'Dart'
'is'
'fun!'; // 'Dart is fun!'
-------------------------

They also work when using multi-line strings:

----------------------------------------
var lunch = '''Peanut
butter'''
'''and
jelly'''; // 'Peanut\nbutter and\njelly'
----------------------------------------

You can concatenate adjacent single-line literals with multi-line strings:

--------------------------------------
var funnyGuys = 'Dewey ' 'Cheatem'
''' and
Howe'''; // 'Dewey Cheatem and\n Howe'
--------------------------------------

===== Alternatives to adjacent string literals

You can use the `concat()` method on a string to concatenate it to
another string:

---------------------------------------------------
var film = filmToWatch();
film = film.concat('\n');  // 'The Big Lebowski\n' 
---------------------------------------------------

Because `concat()` creates a new string every time it is invoked, a long
chain of `concat()` s can be expensive. Avoid those. Use a StringBuffer
instead (see _Incrementally building a string efficiently using a
StringBuffer_, below).

Use `join()` to combine a sequence of strings:

-----------------------------------------------------------------------
var film = ['The', 'Big', 'Lebowski']).join(' '); // 'The Big Lebowski'
-----------------------------------------------------------------------

You can also use string interpolation to concatenate strings (see
_Interpolating expressions inside strings_, below).

=== Interpolating expressions inside strings

==== Problem

You want to embed Dart code inside strings.

==== Solution

You can put the value of an expression inside a string by using
$\{expression}.

----------------------------------------------------------------------
var favFood = 'sushi';
var whatDoILove = 'I love ${favFood.toUpperCase()}'; // 'I love SUSHI'
----------------------------------------------------------------------

You can skip the \{} if the expression is an identifier:

------------------------------------------------------
var whatDoILove = 'I love $favFood'; // 'I love sushi'
------------------------------------------------------

==== Discussion

The interpolated string, `'string ${expression}` is equivalent to the
concatenation of the strings `string` and `expression.toString()`.
Consider this code:

-----------------------------------------------------
var four = 4;
var seasons = 'The $four seasons'; // 'The 4 seasons'
-----------------------------------------------------

This is functionally equivalent to the following:

-------------------------------------------------------------
var seasons = 'The '.concat(4.toString()).concat(' seasons');
// 'The 4 seasons'
-------------------------------------------------------------

You should consider implementing a `toString()` method for classes that you
define. Here's what happens if you don't:

-------------------------------------------------------
class Point {
  num x, y;
  Point(this.x, this.y);
}

var point = new Point(3, 4);
print('Point: $point'); // "Point: Instance of 'Point'"
-------------------------------------------------------

Probably not what you wanted. Here is the same example with an explicit
`toString()`:

----------------------------------------------
class Point {
  ...
    
  String toString() => 'x: $x, y: $y';
}

print('Point: $point'); // 'Point: x: 3, y: 4'
----------------------------------------------

=== Handling special characters within strings

==== Problem

You want to put newlines, dollar signs, or other special characters in strings.

==== Solution

Prefix special characters with a `\`.

------------------------
  print('Wile\nCoyote'); 
  // Wile
  // Coyote
------------------------

==== Discussion

Dart designates a few characters as special, and these can be escaped:

* \n for newline, equivalent to \x0A.
* \r for carriage return, equivalent to \x0D.
* \f for form feed, equivalent to \x0C.
* \b for backspace, equivalent to \x08.
* \t for tab, equivalent to \x09.
* \v for vertical tab, equivalent to \x0B.

If you prefer, you can use `\x` or `\u` notation to indicate the special
character:

-----------------------------------------------------------
print('Wile\x0ACoyote');   // Same as print('Wile\nCoyote')
print('Wile\u000ACoyote'); // Same as print('Wile\nCoyote') 
-----------------------------------------------------------

You can also use `\u{}` notation:

-------------------------------------------------------------
print('Wile\u{000A}Coyote'); // same as print('Wile\nCoyote')
-------------------------------------------------------------

You can also escape the `$` used in string interpolation:

-------------------------------------------------------------------------
var superGenius = 'Wile Coyote';
print('$superGenius and Road Runner');  // 'Wile Coyote and Road Runner'
print('\$superGenius and Road Runner'); // '$superGenius and Road Runner'
-------------------------------------------------------------------------

If you escape a non-special character, the `\` is ignored:

-------------------------------------------
print('Wile \E Coyote'); // 'Wile E Coyote'
-------------------------------------------


=== Incrementally building a string using a StringBuffer

==== Problem

You want to collect string fragments and combine them in an efficient
manner.

==== Solution

Use a StringBuffer to programmatically generate a string. Consider this code
below for assembling a series of urls from fragments:

--------------------------------------------------------------------------
var data = [{'scheme': 'https', 'domain': 'news.ycombinator.com'}, 
            {'domain': 'www.google.com'}, 
            {'domain': 'reddit.com', 'path': 'search', 'params': 'q=dart'}
           ];

String assembleUrlsUsingStringBuffer(entries) {
  StringBuffer sb = new StringBuffer();
  for (final item in entries) {
    sb.write(item['scheme'] != null ? item['scheme']  : 'http');
    sb.write("://");
    sb.write(item['domain']);
    sb.write('/');
    sb.write(item['path'] != null ? item['path']  : '');
    if (item['params'] != null) {
      sb.write('?');
      sb.write(item['params']);
    }
    sb.write('\n');
  }
  return sb.toString();
}

// https://news.ycombinator.com/
// http://www.google.com/
// http://reddit.com/search?q=dart
--------------------------------------------------------------------------

A StringBuffer collects string fragments, but does not generate a new string
until `toString()` is called. 

==== Discussion

Using a StringBuffer is vastly more efficient than concatenating fragments
at each step: Consider this rewrite of the above code:

-------------------------------------------------------------------------
String assembleUrlsUsingConcat(entries) {
  var urls = '';
  for (final item in entries) {
    urls = urls.concat(item['scheme'] != null ? item['scheme']  : 'http');
    urls = urls.concat("://");
    urls = urls.concat(item['domain']);
    urls = urls.concat('/');
    urls = urls.concat(item['path'] != null ? item['path']  : '');
    if (item['params'] != null) {
      urls = urls.concat('?');
      urls = urls.concat(item['params']);
    }
    urls = urls.concat('\n');
  }
  return urls;
}
-------------------------------------------------------------------------

This approach produces the exact same result, but incurs the cost of
joining strings multiple times. 

See the _Concatenating Strings_ recipe for a description of `concat()`.

===== Other StringBuffer methods

In addition to `write()`, the StringBuffer class provides methods to
write a list of strings (`writeAll()`), write a numerical character code
(`writeCharCode()`), write with an added newline (`writeln()`), and
more. The example below shows how to use these methods:

-------------------------------------------------------------------------------
var sb = new StringBuffer();
sb.writeln('The Beatles:');
sb.writeAll(['John, ', 'Paul, ', 'George, and Ringo']);
sb.writeCharCode(33); // charCode for '!'.
var beatles = sb.toString(); // 'The Beatles:\nJohn, Paul, George, and Ringo!' 
-------------------------------------------------------------------------------


=== Determining whether a string is empty

==== Problem

You want to know whether a string is empty. You tried `if (string) {...}`, but
that did not work.

==== Solution

Use `string.isEmpty`:

-----------------------------------
var emptyString = '';
print(emptyString.isEmpty); // true
-----------------------------------

You can also just use `==`:

---------------------------------------------------
if (string == '') {...} // True if string is empty.
---------------------------------------------------

A string with a space is not empty:

-----------------------
var space = ' ';
print(space.isEmpty); // false
-----------------------

==== Discussion

Don't use `if (string)` to test the emptiness of a string. In Dart, all objects
except the boolean true evaluate to false, so `if(string)` is always false. You
will see a warning in the editor if you use an 'if' statement with a non-boolean
in checked mode.


=== Removing leading and trailing whitespace

==== Problem

You want to remove spaces, tabs, and other whitespace from the beginning and
end of strings.

==== Solution

Use `string.trim()`:

-----------------------------------------------------------------
var space = '\n\r\f\t\v';       // A variety of space characters.
var string = '$space X $space';
var newString = string.trim();  // 'X'
-----------------------------------------------------------------

The String class has no methods to remove only leading or only trailing
whitespace. You can always use a RegExp.

Remove only leading whitespace:

-------------------------------------------------------------------------------
var newString = string.replaceFirst(new RegExp(r'^\s+'), ''); // 'X \n\r\f\t\v'
-------------------------------------------------------------------------------

Remove only trailing whitespace:

-------------------------------------------------------------------------------
var newString = string.replaceFirst(new RegExp(r'\s+$'), ''); // '\n\r\f\t\v X'
-------------------------------------------------------------------------------


=== Changing string case

==== Problem

You want to change the case of strings.

==== Solution

Use String's `toUpperCase()` and `toLowerCase()` methods: 

----------------------------------------------------------------------
var theOneILove = 'I love Lucy';
theOneILove.toUpperCase();                           // 'I LOVE LUCY!'
theOneILove.toLowerCase();                           // 'i love lucy!'

// Zeus in modern Greek.
var zeus = '\u0394\u03af\u03b1\u03c2';               // 'Δίας'
zeus.toUpperCase();                                  // 'ΔΊΑΣ'

var resume = '\u0052\u00e9\u0073\u0075\u006d\u00e9'; // 'Résumé'
resume.toLowerCase();                                // 'résumé'
----------------------------------------------------------------------

The `toUpperCase()` and `toLowerCase()` methods don't affect the characters of
scripts such as Devanagri that don't have distinct letter cases.

------------------------------------------------------------------------
var chickenKebab = '\u091a\u093f\u0915\u0928 \u0915\u092c\u093e\u092c'; 
// 'चिकन कबाब'  (in Devanagari)
chickenKebab.toLowerCase();  // 'चिकन कबाब'
chickenKebab.toUpperCase();  // 'चिकन कबाब'
------------------------------------------------------------------------

If a character's case does not change when using `toUpperCase()` and
`toLowerCase()`, it is most likely because the character only has one
form.


=== Handling extended characters that are composed of multiple code units

==== Problem

You want to use emoticons and other special symbols that don't fit into 16
bits. How can you create such strings and use them correctly in your code? 

==== Solution

You can create an extended character using `'\u{}'` syntax:

------------------------------
var clef = '\u{1D11E}'; // 𝄞
------------------------------

==== Discussion

Most UTF-16 strings are stored as two-byte (16 bit) code sequences.
Since two bytes can only contain the 65,536 characters in the 0x0 to 0xFFFF
range, a pair of strings is used to store values in the 0x10000 to 0x10FFFF
range. These strings only have semantic meaning as a pair. Individually, they
are invalid UTF-16 strings. The term 'surrogate pair' is often used to
describe these strings. 

The treble clef glyph `'\u{1D11E}'` is composed of the `'\uD834'` and
`'\uDD1E'` surrogate pair.

You can get an extended string's surrogate pair through its `codeUnits`
property:

-------------------------------------------------------------------------------
clef.codeUnits.map((codeUnit) => codeUnit.toRadixString(16)); 
// ['D834', 'DD1E']
-------------------------------------------------------------------------------

Accessing a surrogate pair member leads to errors, and you should avoid
properties and methods that expose it:

-------------------------------------------------------------------------------
print('\uD834');          // Error: '\uD834' is not a valid string.
print('\uDD1E');          // Error: '\uDD1E' is not a valid string either.
print(clef.split('')[1]); // Invalid string. Dart Editor prints '?'
print(clef[0]);           // Invalid string. Dart Editor prints '?'
-------------------------------------------------------------------------------

When dealing with strings containing extended characters, you should use the
`runes` getter.

To get the string's length, use `string.runes.length`. Don't use
`string.length`:

-------------------------------------------------------------------------------
print(clef.runes.length);     // 1
print(clef.length);           // 2
print(clef.codeUnits.length); // 2
-------------------------------------------------------------------------------

To get an individual character or its numeric equivalent, index the rune list:

--------------------------------------------------------------
print(clef.runes.toList()[0]); // 119070 ('\u{1D11E}')
--------------------------------------------------------------

To get the string's characters as a list, map the string runes:

---------------------------------------------------------------------------
var clef = '\u{1D11E}'; // 𝄞
var title = '$clef list:'
print(subject.runes.map((rune) => new String.fromCharCode(rune)).toList());
// ['𝄞', ' ', 'l', 'i', 's', 't', ':']
---------------------------------------------------------------------------


=== Converting between characters and numerical codes

==== Problem

You want to convert string characters into numerical codes and vice versa.
You want to do this because sometimes you need to compare characters in a string
to numerical values coming from another source. Or, maybe you want to split a
string and then operate on each character.

==== Solution

Use the `runes` getter to get a string's code points:

-----------------------------------------------------------------------------
'Dart'.runes.toList();            // [68, 97, 114, 116]

var smileyFace = '\u263A';        // ☺
print(smileyFace.runes.toList()); // [9786], (equivalent to ['\u263A']).

var clef = '\u{1D11E}';           // 𝄞
print(clef.runes.toList());       // [119070], (equivalent to ['\u{1D11E}']).
-----------------------------------------------------------------------------

Use `string.codeUnits` to get a string's UTF-16 code units:

----------------------------------------------------
'Dart'.codeUnits.toList();     // [68, 97, 114, 116]
smileyFace.codeUnits.toList(); // [9786]
clef.codeUnits.toList();       // [55348, 56606]
----------------------------------------------------

===== Using codeUnitAt() to get individual code units

To get the code unit at a particular index, use `codeUnitAt()`:

----------------------------------------------------------------------
'Dart'.codeUnitAt(0);     // 68
smileyFace.codeUnitAt(0); // 9786 (the decimal value of '\u263A')
clef.codeUnitAt(0);       // 55348 (does not represent a legal string) 
----------------------------------------------------------------------

==== Converting numerical codes to strings

You can generate a new string from numerical codes using the factory
`String.fromCharCodes(charCodes)`. You can pass either runes or code units and
`String.fromCharCodes(charCodes)` can tell the difference and do the right
thing automatically:

-------------------------------------------------------------------------------
print(new String.fromCharCodes([68, 97, 114, 116]));                  // 'Dart'

print(new String.fromCharCodes([73, 32, 9825, 32, 76, 117, 99, 121]));
// 'I ♡ Lucy'

// Passing code units representing the surrogate pair.
print(new String.fromCharCodes([55348, 56606]));                      // 𝄞

// Passing runes.
print(new String.fromCharCodes([119070]));                            // 𝄞
-------------------------------------------------------------------------------

You can use the `String.fromCharCode()` factory to convert a single rune
or code unit to a string:

---------------------------------------
new String.fromCharCode(68);     // 'D'
new String.fromCharCode(9786);   // ☺
new String.fromCharCode(119070); // 𝄞
---------------------------------------

Creating a string with only one half of a surrogate pair is permitted,
but not recommended.


=== Calculating the length of a string

==== Problem

You want to get the length of a string, but are not sure how to calculate the
length correctly when working with variable length Unicode characters.

==== Solution

Use `string.runes.length` to get the number of characters in a string.

-----------------------------------------
print('I love music'.runes.length); // 12
-----------------------------------------

You can safely use `string.runes.length` to get the length of strings that
contain extended characters:

-----------------------------------------
var clef = '\u{1D11E}';        // 𝄞
var subject = '$clef list:';   // 
var music = 'I $hearts $clef'; // 'I ♡ 𝄞'

clef.runes.length;             // 1
music.runes.length             // 5
-----------------------------------------

==== Discussion

You can directly use a string's `length` property (minus `runes`). This returns
the string's code unit length. Using `string.length` produces the same length
as `string.runes.length` for most unicode characters.

For extended characters, the code unit length is one more than the rune
length:

------------------------------------------
clef.length;                   // 2

var music = 'I $hearts $clef'; // 'I ♡ 𝄞'
music.length;                  // 6
------------------------------------------

Unless you specifically need the code unit length of a string, use
`string.runes.length`.

===== Working with combined characters

It is tempting to brush aside the complexity involved in dealing with runes and
code units and base the length of the string on the number of characters it
appears to have. Anyone can tell that 'Dart' has four characters, and 'Amelié'
has six, right? Almost. The length of 'Dart' is indeed four, but the length of
'Amelié' depends on how that string was constructed:

---------------------------------------------------
var name = 'Ameli\u00E9';               // 'Amelié'
var anotherName = 'Ameli\u0065\u0301';  // 'Amelié'
print(name.length);                     // 6
print(anotherName.length);              // 7
---------------------------------------------------

Both `name` and `anotherName` return strings that look the same, but where
the 'é' is constructed using a different number of runes. This makes it
impossible to know the length of these strings by just looking at them.


=== Processing a string one character at a time

==== Problem

You want to do something with each character in a string.

==== Solution

Map the results of calling `string.split('')`:

----------------------------------------------------------
var lang= 'Dart';

// ['*D*', '*a*', '*r*', '*t*']
print(lang.split('').map((char) => '*${char}*').toList());

var smileyFace = '\u263A';
var happy = 'I am $smileyFace';
print(happy.split('')); // ['I', ' ', 'a', 'm', ' ', '☺']
----------------------------------------------------------

Or, loop over the characters of a string:

--------------------------------------------
var list = [];
for(var i = 0; i < lang.length; i++) {
  list.add('*${lang[i]}*'); 
}

print(list); // ['*D*', '*a*', '*r*', '*t*']
--------------------------------------------

Or, map the string runes:

------------------------------------------------------------------------
// ['*D*', '*a*', '*r*', '*t*']
var charList = "Dart".runes.map((rune) {
  return '*${new String.fromCharCode(rune)}*').toList();
});

// [[73, 'I'], [32, ' '], [97, 'a'], [109, 'm'], [32, ' '], [9786, '☺']]
var runeList = happy.runes.map((rune) {
  return [rune, new String.fromCharCode(rune)]).toList();
});
------------------------------------------------------------------------

When working with extended characters, you should always map the string runes.
Don't use `split('')` and avoid indexing an extended string. See the _Handling
extended characters that are composed of multiple code units_ recipe for
special considerations when working with extended strings.


=== Splitting a string into substrings

==== Problem

You want to split a string into substrings using a delimiter or a pattern.

==== Solution

Use the `split()` method with a string or a RegExp as an argument.

-------------------------------------
var smileyFace = '\u263A';
var happy = 'I am $smileyFace';
happy.split(' '); // ['I', 'am', '☺']
-------------------------------------

Here is an example of using `split()` with a RegExp:

--------------------------------------------------------------
var nums = '2/7 3 4/5 3~/5';
var numsRegExp = new RegExp(r'(\s|/|~/)');
nums.split(numsRegExp); // ['2', '7', '3', '4', '5', '3', '5']
--------------------------------------------------------------

In the code above, the string `nums` contains various numbers, some of which
are expressed as fractions or as int-divisions. A RegExp splits the string to
extract just the numbers.

You can perform operations on the matched and unmatched portions of a string
when using `split()` with a RegExp:

----------------------------------------------------------------
var phrase = 'Eats SHOOTS leaves';

var newPhrase = phrase.splitMapJoin((new RegExp(r'SHOOTS')),
  onMatch:    (m) => '*${m.group(0).toLowerCase()}*',
  onNonMatch: (n) => n.toUpperCase());

print(newPhrase); // 'EATS *shoots* LEAVES'
  
----------------------------------------------------------------

The RegExp matches the middle word ('SHOOTS'). A pair of callbacks are
registered to transform the matched and unmatched substrings before the
substrings are joined together again.


=== Determining whether a string contains another string

==== Problem

You want to find out whether a string is the substring of another string.

==== Solution

Use `string.contains()`:

---------------------------------------------
var fact = 'Dart strings are immutable';
print(fact.contains('immutable')); // True.
---------------------------------------------

You can use a second argument to specify where in the string to start looking:

-----------------------------------------
print(fact.contains('Dart', 2)); // False
-----------------------------------------

==== Discussion

The String class provides a couple of shortcuts for testing whether a
string is a substring of another:

------------------------------------------
print(string.startsWith('Dart')); // True.
print(string.endsWith('e'));      // True.
------------------------------------------

You can also use `string.indexOf()`, which returns -1 if the substring
is not found within a string, and otherwise returns the matching index:

---------------------------------------------------------------------------
var found = string.indexOf('art') != -1; // True, `art` is found in `Dart`.
---------------------------------------------------------------------------

You can also use a RegExp and `hasMatch()`:

------------------------------------------------------------------------
var found = new RegExp(r'ar[et]').hasMatch(string);
//  True, 'art' and 'are' match.
------------------------------------------------------------------------

=== Finding matches of a regular expression

==== Problem

You want to use RegExp to match a pattern in a string, and want to be
able to access the matches.

==== Solution

Construct a regular expression using the RegExp class, and find matches
using the `allMatches()` method:

-------------------------------------------------------------------------
var neverEatingThat = 'Not with a fox, not in a box';
var regExp = new RegExp(r'[fb]ox');
List matches = regExp.allMatches(neverEatingThat);
print(matches.map((match) => match.group(0)).toList()); // ['fox', 'box']
-------------------------------------------------------------------------

==== Discussion

You can query the object returned by `allMatches()` to find out the
number of matches:

-----------------------------------------
var howManyMatches = matches.length; // 2
-----------------------------------------

To find the first match, use `firstMatch()`:

----------------------------------------------------------------------
var firstMatch = RegExp.firstMatch(neverEatingThat).group(0); // 'fox'
----------------------------------------------------------------------

To directly get the matched string, use `stringMatch()`:

------------------------------------------------------------
print(regExp.stringMatch(neverEatingThat));         // 'fox'
print(regExp.stringMatch('I like bagels and lox')); // null
------------------------------------------------------------

=== Substituting strings using regular expressions

==== Problem

You want to match substrings within a string and make substitutions
based on the matches.

==== Solution

Construct a regular expression using the RegExp class and make
replacements using `replaceAll()` method:

-------------------------------------------------------------------------
var resume = 'resume'.replaceAll(new RegExp(r'e'), '\u00E9'); // 'résumé'
-------------------------------------------------------------------------

If you want to replace just the first match, use `replaceFirst()`:

-----------------------------------------------------------------------
// Replace the first match of one or more zeros with an empty string.
var smallNum = '0.0001'.replaceFirst(new RegExp(r'0+'), ''); // '.0001'
-----------------------------------------------------------------------

You can use `replaceAllMapped()` to register a function that modifies the
matches:

---------------------------------------------------------
var heart = '\u2661'; // '♡'
var string = 'I like Ike but I $heart Lucy';
var regExp = new RegExp(r'[A-Z]\w+');
var newString = string.replaceAllMapped(regExp, (match) {
  return match.group(0).toUpperCase()
}); 
print(newString); // 'I like IKE but I ♡ LUCY'
---------------------------------------------------------


== Lists

=== Creating a fixed width or const list

==== Problem

You want to create a list but don't want to allow it's size to be
changed.

==== Solution

Create a fixed-length list:

-------------------------------------------------------------------
var fixedList = new List(3); // fixedList can have exactly 3 items.
-------------------------------------------------------------------

Attempting to change the size of the list generates an error:

-------------------------------------------
fixedList.add(2);       // UnsupportedError
fixedList.removeLast(); // UnsupportedError
fixedList.length = 10;  // UnsupportedError
-------------------------------------------

You can change the values in the list:

---------------------------------------------
fixedList[0] = 'red';
fixedList[1] = 'green';
fixedList[2] = 'blue';
print(fixedList); // ['red', 'green', 'blue']
---------------------------------------------

If you want a fixed-length list _and_ you don't want the contents of the list
to change, create a `const` list:

------------------------------------------------------------
const List<String> vowels = const ['A', 'E', 'I', 'O', 'U'];

vowels.add('Y'); // UnsupportedError
vowels[0] = 'a'; // UnsupportedError
------------------------------------------------------------


=== Creating a list with default fill values

==== Problem

You want to create a list and fill it with default values.

==== Solution

You can fill a fixed-length list with a static value by using the
`List.filled()` constructor:

-------------------------------------------------------
var filledList = new List.filled(3, 'X');
print(filledList.every((item) => item == 'X')); // true
-------------------------------------------------------

If you want to generate the fill values dynamically, you can call the
`List.generate()` constructor and pass it a function that generates the fill
values:

-------------------------------------------------
var arr = [1, 2, 3];
List<List<int>> grid = new List.generate(3, (_) {
  var temp = arr;
  arr = arr.map((item) => item += 3).toList();
  return temp;
});
-------------------------------------------------

The code above generates a 3 X 3 grid:

-------------------------------------------------
print(grid); // [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
-------------------------------------------------

=== Create a new list with the elements of another list

==== Problem

You want to copy the contents of a list into a new list. 

==== Solution

Use the `List.from()` constructor and pass the list you want to copy from as
an argument:

-------------------------------------------
var fruit1 = ['orange', 'banana', 'mango'];
var fruit2 = new List.from(fruit1);
-------------------------------------------

By default, the new list created will be growable. This is true even if you
passed a `const` list as an argument to `List.from()`:

-------------------------------------------------------------
const List<String> vowels1 = const ['A', 'E', 'I', 'O', 'U'];
var vowels2 = new List.from(vowels1);

vowels2.add('Y');
print(vowels2); // ['A', 'E', 'I', 'O', 'U', 'Y']

vowels2[0] = 'Y';
print(vowels2[0]); // 'Y'
-------------------------------------------------------------

To create a fixed-width list, pass a second `growable` argument to
`List.from()` with a value of `false`:

----------------------------------------------------------
const List<String> vowels1 = const ['A', 'E', 'I', 'O', 'U'];
var vowelsFixed = new List.from(vowels1, growable: false);
var fruitFixed = new List.from(fruit1, growable: false);

vowelsFixed.add('Y'); // UnsupportedError
vowelsFixed.add('Y'); // UnsupportedError

vowelsFixed[0] = 'Y';
print(vowelsFixed[0]); 'Y'
----------------------------------------------------------

=== Appending items to a list

==== Problem

You want to add items to the end of a list, and want to know the most
efficient way to do so.

==== Solution

Dart lists are implemented using dynamic arrays. Adding to the end of a list
is efficient and fast. 

To add one item at a time, use the `add()` method:

-------------------------------------------------------------
var names = ['Seth', 'Timothy', 'John'];
names.add('Kathy');
names.add('Mary');
print(names); // ['Seth', 'Timothy', 'John', 'Kathy', 'Mary']
-------------------------------------------------------------

If the items to be added are already in a list, you can add them all at once
using the `addAll()` method:

-------------------------------------------------------------
var names = ['Seth', 'Timothy', 'John'];
names.addAll(['Kathy', 'Mary']);
print(names); // ['Seth', 'Timothy', 'John', 'Kathy', 'Mary']
-------------------------------------------------------------

Or, you can increase the `length` property of a list. Doing this allocates
space for the new items which are initialized to `null`:

--------------------------------------------------------
print(names); // ['Seth', 'Timothy', 'John', null, null]
--------------------------------------------------------

You can then assign elements to the positions with `null` values:

----------------------------------------------------------
var names = ['Seth', 'Timothy', 'John'];
var moreNames = ['Kathy', 'Mary'];
      
var namesLen = names.length;
names.length += 2; // Create space for 2 more items created.
      
for (var i = 0; i < moreNames.length; i++) {
  names[i + namesLen] = moreNames[i];
}

print(names); ['Seth', 'Timothy', 'John', 'Kathy', 'Mary']
----------------------------------------------------------

Manipulating the length property is a useful optimization strategy: you incur
the cost of allocating memory for the new items just once. On a MacBook,
appending items in this manner work approximately twice as fast as using
`add()` or `addAll()`.


== Numbers

=== Converting a string to a number

==== Problem

You want to parse a string and convert it to a number.

==== Solution

Use `int.parse` to convert a string to an int:

--------------------------------------------------------------------------------
print(int.parse('231')); // 231
--------------------------------------------------------------------------------

The strings can be prefixed with a '+' or a '-':

--------------------------------------------------------------------------------
print(int.parse('+231')); // 231
print(int.parse('-231')); // -231
--------------------------------------------------------------------------------
    
You can pass in the radix as a second argument:

--------------------------------------------------------------------------------
print(int.parse('231', radix: 16));  // 561
print(int.parse('F34A', radix: 16)); // 62282
--------------------------------------------------------------------------------
    
Strings starting with '0x', '-0x' or '+0x' are assumed to have a radix of 16:

--------------------------------------------------------------------------------
print(int.parse('0x231')); // 561
--------------------------------------------------------------------------------

Use `double.parse` to convert a string to a double:

--------------------------------------------------------------------------------
print(double.parse('3.14')); // 3.14
--------------------------------------------------------------------------------
    
The method accepts exponential notation:

--------------------------------------------------------------------------------
print(double.parse('3.14e5')); // 314000.0
--------------------------------------------------------------------------------

Both `int.parse` and `double.parse` throw a FormatException if they are passed
invalid arguments.


=== Converting a number to a string

==== Problem

You want to convert a number to a string.

==== Solution

Use `toString()` for a no-frills number to string conversion:

--------------------------------------------------------------------------------
1234.toString();   // '1234'
3.1519.toString(); // '3.1519'
--------------------------------------------------------------------------------

To specify the number of signficant digits, use the `toStringAsPrecision()`
method: 

--------------------------------------------------------------------------------
1234.toStringAsPrecision(5);   // '1234.0'
3.1519.toStringAsPrecision(8); // '3.1519000'
--------------------------------------------------------------------------------
  
To specify the number of digits after the decimal, use `toStringAsFixed()`:

--------------------------------------------------------------------------------
1234.toStringAsFixed(2);   // '1234.00'
3.1519.toStringAsFixed(2); // '3.15'
--------------------------------------------------------------------------------

To convert the number to decimal exponential notation, use the
`toStringAsExponential()` method: 

--------------------------------------------------------------------------------
1234.toStringAsExponential();   // '1.234e+3'
--------------------------------------------------------------------------------

You can specify the radix when converting an integer to a string:

--------------------------------------------------------------------------------
64.toRadixString(2);  // '1000000'
64.toRadixString(8);  // '100'
64.toRadixString(16); // '40'
--------------------------------------------------------------------------------


== Json

=== Encoding JSON

==== Problem

You want to convert a Dart object into JSON.

==== Solution

Use `json.stringify()` to encode a Dart object into a JSON-formatted string.

The following Dart objects are automatically encoded into JSON by
`json.stringify()`:

* int
* double
* String
* bool
* null
* List
* Map

--------------------------------------------------------------------------------
var person = {'name': 'joe', 
              'born':  2002,
              'into': {'films' : ['crime', 'noir']},
              'aliases': null
             };

json.stringify(person);
// '{"name":"joe","born":2002,"into":{"films":["crime","noir"]},"aliases":null}'
--------------------------------------------------------------------------------

Note that `json.stringify()` encodes List and Map objects recursively.

If an object of a type not in the list above is passed to `json.stringify()`,
it calls that objects `toJson()` method:

--------------------------------------------------------------------------------
class Person {
  String name;
  num age;
  
  Person(this.name, this.age);
 
  String toJson() => json.stringify({"name": name, "age": age});
}

var person = new Person('john', 32);
json.stringify(person); // '"{\"name\":\"john\",\"age\":32}"'
--------------------------------------------------------------------------------

If the `toJson()` method is not defined, `json.stringify()` throws an exception:

--------------------------------------------------------------------------------
class Book {
  String title;
  num numPages;
 
  Book(this.title, this.numPages);
}

var book = new Book('War and Peace', 1089);
json.stringify(book); // json.JsonUnsupportedObjectError
--------------------------------------------------------------------------------

It is possible that `json.stringify()` calls `toJson()` on several objects,
and if any one of those objects lacks a `toJson()`, an exception gets thrown.
Use ` JsonUnsupportedObjectError`'s `cause` property to see which object
triggered the exception:

--------------------------------------------------------------------------------
var person = new Person('john', 32);          // Has a toJson().
var book = new Book('War and Peace', 1089);   // Lacks a toJson().
var object = {'person': person, 'reads' : book};

try {
  json.stringify(object);
} catch(e) {
  print(e.cause.toString());
  // "Class 'Book' has no instance method 'toJson'..."
}
--------------------------------------------------------------------------------


=== Decoding JSON

==== Problem

You want to convert a JSON string into a Dart object.

==== Solution

Use `json.parse()` to decode a JSON-encoded string into a Dart object:

--------------------------------------------------------------------------------
var jsonPerson = '{"name" : "joe", "date" : [2013, 3, 10]}';
  
var person = json.parse(jsonPerson);

person['name'];         // 'joe'
person['date'];         // [2013, 3, 10]
person['date'] is List; // true
    
Sometimes you want to transform the data parsed by `json.parse`. For
example, you may prefer to express a date field as a DateTime object, and not
as a list of numbers representing the year, month and day. Specify a 'reviver'
function as a second argument to `json.parse`. 

This function is called once for each object or list property parsed, and the 
return value of the reviver function is used instead of the parsed value:

--------------------------------------------------------------------------------
var jsonPerson = '{"name" : "joe", "date" : [2013, 3, 10]}';

var person = json.parse(jsonPerson, (k, v) {
  if (k == "date") {
    return new DateTime(v[0], v[1], v[2]);
  }
  return v;
});
      
person['name'];             // 'joe'
person['date'] is DateTime; // true
--------------------------------------------------------------------------------


== URIs

Note: all examples require that you load 'dart:uri':

--------------------------------------------------------------------------------
import 'dart:uri';
--------------------------------------------------------------------------------


=== Encoding and Decoding Fully Qualified URIs


Use `encodeUri()` to encode a fully qualified URI:

--------------------------------------------------------------------------------
encodeURI('http://www.example.com/file with spaces.html')
// 'http://www.example.com/file+with+spaces.html'
--------------------------------------------------------------------------------

Characters that have special meaning in the URI (such as #;,/?:@&=$) are not
escaped:

--------------------------------------------------------------------------------
encodeUri('http://example.com/?x=10&y=20#last');
// 'http://example.com/?x=10&y=20#last'

encodeUri('mailto:bob@example.com'); // 'mailto:bob@example.com'
--------------------------------------------------------------------------------

Call `encodeUriComponent()` to encode any user-provided parameters that are
passed to the server as part of a URI:

--------------------------------------------------------------------------------
var params = encodeUriComponent('?param1=10&param2=20');
print(params); // '%3Fparam1%3D10%26param2%3D20'

encodeUri('http://www.example.com/') + params;
// 'http://www.example.com/%3Fparam1%3D10%26param2%3D20'));
--------------------------------------------------------------------------------
      
Don't call `encodeUriComponent()` on the complete URI. It escapes characters
like : and / and renders the URI unusable:

--------------------------------------------------------------------------------
encodeUriComponent('http://www.example.com/'); 
// 'http%3A%2F%2Fwww.example.com%2F'
--------------------------------------------------------------------------------

To decode a URI previously encoded using `encodeUri()`, use `decodeUri()`:

--------------------------------------------------------------------------------
var uri = 'http://www.example.com/file with spaces.html';
var encodedUri = encodeUri(uri);
decodeUri(encodedUri) == uri; // true
--------------------------------------------------------------------------------

To decode a URI component previously encoded using `encodeUriComponent()`, use
`decodeUriComponent()`: 

--------------------------------------------------------------------------------
var params = encodeUriComponent('?param1=10&param2=20');
var encodedParams = encodeUriComponent(params);
decodeUriComponent(encodedParams) == params; // true
--------------------------------------------------------------------------------


=== Parsing URIs

==== Problem

You want to access the parts of a URI.

==== Solution

The properties of a URI created using the `Uri()` constructor can be directly
accessed in the following manner: 

--------------------------------------------------------------------------------
var uri = new Uri('http://example.org:8080/content/a.html#intro');

uri.scheme;     // 'http'
uri.userInfo;   // ''
uri.port        // ''
uri.domain;     // 'example.org'
uri.path;       // '/content/a.html'
uri.fragment;   // 'intro'
--------------------------------------------------------------------------------

Get the query parameters using the URI's `query` property:

--------------------------------------------------------------------------------
var params = 'name=john&age=32';
var uri = new Uri('http://example.org/?name=john&age=32');
uri.query; // 'name=john&age=32'
--------------------------------------------------------------------------------

For http/https schemes, you can access the `origin` property:

--------------------------------------------------------------------------------
var uri = new Uri('http://example.org:8080/content/a.html#intro');
uri.origin;     // 'http://example.org:8080'
--------------------------------------------------------------------------------

==== Discussion

The Uri class treats all URs that do not explicitly begin with a scheme as
relative:

--------------------------------------------------------------------------------
new Uri('//example.org:8080/content/').isAbsolute; // false
new Uri('example.org:8080/content/').isAbsolute;   // false
--------------------------------------------------------------------------------

URIs that begin with a scheme, but that contain a fragment, are also considered
relative:

--------------------------------------------------------------------------------
new Uri('http//example.org:8080/content/#intro').isAbsolute; // false
--------------------------------------------------------------------------------
    
The `scheme` and `domain` properties for  relative URIs are empty. Instead, a 
relative URI starts with the path component:

--------------------------------------------------------------------------------
var uri = new Uri('example.org/content/a.html#intro');
      
uri.isAbsolute; // false
uri.scheme;     // ''
uri.domain;     // ''
uri.path;       // 'example.org/content/a.html'
--------------------------------------------------------------------------------

Accessing the `origin` property of a relative URI throws an exception:

--------------------------------------------------------------------------------
var uri = new Uri('example.org/content/a.html#intro');
uri.isAbsolute; // false

try {
  var origin = uri.origin;
} catch(e) {
  print(e); // 'Illegal argument(s): Cannot use origin without a scheme'
}
--------------------------------------------------------------------------------
      

=== Building URIs

==== Problem

You want to build URIs from individual parts.

==== Solution

Use the `Uri.fromComponents()` constructor to build up a URI from individual
parts:

--------------------------------------------------------------------------------
var uri = new Uri.fromComponents(
  scheme: 'http',
  domain: 'example.org',
  path: '/content/a.html',
  query: 'name=john');

uri.isAbsolute;        // true
print(uri.toString()); // 'http://example.org/content/a.html?name=john'
--------------------------------------------------------------------------------

If you do not pass in the scheme as an argument, `Uri.fromComponents()` creates
a relative URI, and prefixes the URI with leading '//`:

--------------------------------------------------------------------------------
var uri = new Uri.fromComponents(domain: '/content/a.html');
         
uri.isAbsolute;       // false
print(uri.toString(); // '//content/a.html'
--------------------------------------------------------------------------------
 
You should remove the leading '//' before using the URI.


== Testing

=== Running only a single test

==== Problem

You want to run just a single test.  Maybe it is the test you are
currently working on and want to make that pass before running all your tests.
Or, perhaps it is a failing test that you want to explore in the debugger,
without dealing with the noise from other tests. 

==== Solution

To isolate a test, change `test()` to `solo_test()`.

--------------------------------------------------------------------------------
test('if y == 0', ()  => expect(() => ...));
solo_test('if y != 0', () => expect(() => ...));
--------------------------------------------------------------------------------

Only the `solo_test()` will run:

--------------------------------------------------------------------------------
unittest-suite-wait-for-done
PASS: if y != 0

All 1 tests passed.
unittest-suite-success
--------------------------------------------------------------------------------

Do not have multiple `only_test()`s:

--------------------------------------------------------------------------------
solo_test('if y == 0', () => expect(() => ...));
solo_test('if y != 0', () => expect(() => ...));
--------------------------------------------------------------------------------

This raises an exception, and only the first `solo_test()` runs:

--------------------------------------------------------------------------------
unittest-suite-wait-for-done
Exception: Only one test can be soloed right now.
PASS: if y == 0

All 1 tests passed.
unittest-suite-success
--------------------------------------------------------------------------------


=== Filtering which tests are run

==== Problem

You want to run just a subset of all your tests. Maybe you've divided up
your tests carefully using `group()` and want to run the tests for one or more
group. Or perhaps you carefully placed certain keywords in your test
descriptions, and want to run only tests whose desciption contains a
specific keyword.

==== Solution

Use `filterTests()`. This function takes a String or RegExp argument and
matches it against each test description.  If the description matches, the
test runs, otherwise, it doesn’t.

By default, the Unittest library is configured to run _all_ tests defined in a
file when that file executes. You want to override this behavior. Do that by
subclassing the default Configuration class, and creating a custom
configuration:

--------------------------------------------------------------------------------
class CustomConfiguration extends Configuration {
  get autoStart => false;
}
--------------------------------------------------------------------------------

Then, tell the test runner to use the new configuration:

--------------------------------------------------------------------------------
configure(new CustomConfiguration());
--------------------------------------------------------------------------------

And then, initialize the test library (you need to explicitly do this when using
a custom configuration): 

--------------------------------------------------------------------------------
ensureInitialized();
--------------------------------------------------------------------------------

After this is done, you can define groups and tests, call `filteredTests()`,
and run your tests using `runTests()`:

--------------------------------------------------------------------------------
void main() {
  configure(new CustomConfiguration());
  ensureInitialized();
  
  // Your tests go here.

  filterTests(someStringOrRegExp);
  runTests();
}
--------------------------------------------------------------------------------

A complete example that uses `filterTests()` is shown below. You can run the
code from the command line, adding a keyword argument that is then passed on
to `filterTests()`: 

--------------------------------------------------------------------------------
$ dart filter_tests.dart <keyword>
--------------------------------------------------------------------------------

Here is the code:

--------------------------------------------------------------------------------
import 'package:unittest/unittest.dart';
import 'package:args/args.dart';
import 'dart:io';

class CustomConfiguration extends Configuration {
  get autoStart => false;
}

void main() {
  configure(new CustomConfiguration());
  ensureInitialized();  
  
  // Get the args from the command line.
  ArgParser argParser = new ArgParser();
  Options options = new Options();
  ArgResults results = argParser.parse(options.arguments);
  List<String> args = results.rest;

  test('one test', () => ... ); 
  test('crucial test', () => ... );
  test('another crucial test', =>  ...);

  group('case change', () {
    test('to upper', () => ... );
    test('to lower', () => ... );
  });

  if (!args.isEmpty) {
    filterTests(args[0]);
  }

  runTests();
}
--------------------------------------------------------------------------------

Run the tests with 'crucial' as an argument:

--------------------------------------------------------------------------------
$ dart filter_tests.dart crucial
--------------------------------------------------------------------------------

Only tests with 'crucial' in the description run:

--------------------------------------------------------------------------------
unittest-suite-wait-for-done
PASS: crucial test
PASS: another crucial test

All 2 tests passed.
unittest-suite-success
------------------------------------------------------------------------------

Run the tests with 'case' as an argument: 

--------------------------------------------------------------------------------
$ dart filter_tests.dart case
--------------------------------------------------------------------------------

Only tests within the 'case change' group run:

--------------------------------------------------------------------------------
unittest-suite-wait-for-done
PASS: case change to upper
PASS: case change to lower

All 2 tests passed.
unittest-suite-success
--------------------------------------------------------------------------------

The keyword argument is optional. If you omit it, all tests in the file run:

--------------------------------------------------------------------------------
unittest-suite-wait-for-done
PASS: a test
PASS: crucial test
PASS: another crucial test
PASS: case change to upper
PASS: case change to lower

All 5 tests passed.
unittest-suite-success
--------------------------------------------------------------------------------


=== Running code before and after each test

==== Problem

You want initialization code to run before each test, and cleanup code to run
after each test, but want to avoid code duplication.

==== Solution

Within each `group()`, call `setUp()` for initialization and `tearDown()` for
cleanup. The function passed as an argument to `setUp()` runs before each
test, and that passed to `tearDown()` runs after each test.

===== setUp() example

Assume you have defined a Point class that contains several methods. You want
to test each method, and need a Point object in each test. Place the Point
initialization code inside `setUp()`, and the Point object becomes available in
each test:

--------------------------------------------------------------------------------
void main() {
  group('test Point with setUp()', () {
    Point point;
    setUp(() {  
      point = new Point(3, 4);
    });

    test('toString',  () => expect(point.toString(), equals(...)));
    test('[](index)', () => expect(point[0], equals(...)));
  });
}
--------------------------------------------------------------------------------

===== setUp() and tearDown() example

Tests that create files and directories need to clean up after themselves.
Here is a function that creates a file inside a given directory: 

--------------------------------------------------------------------------------
// Writes a file in 'dir' directory.
Path writeFileToDirectory(dir) {
  ...
}
--------------------------------------------------------------------------------

The code to create the directory goes in `setUp()`. The code to remove the
directory and its contents goes in `tearDown()`:

--------------------------------------------------------------------------------
void main() {
  group('test writeFileToDirectory()', () {
    var tempDir;
    
    setUp(() {
       tempDir = new Directory('').createTempSync();
    });

    tearDown(() {
      if (tempDir.existsSync()) {
        tempDir.deleteSync(recursive: true);
      }
    });

    test('creates the correct path', () => ...);
    test('throws with a non-existent directory', () => ...);
  });
}
--------------------------------------------------------------------------------

The code inside `tearDown()` runs regardless of whether `setUp()` sets up a
resource successfully or not, and regardless of whether a test passes or
fails. If there is an error inside a test, code within `tearDown()` still runs:

--------------------------------------------------------------------------------
group('tearDown behavior when', () {
  var tempDir;

  setUp(() {
    print('setting up');
    tempDir = new Directory('').createTempSync();
  });

  tearDown(() {
    print('tearing down');
    if (tempDir.existsSync()) {
      tempDir.deleteSync(recursive: true);
    }
  });

  test('test has error in it', () {
    22 ~/ 0; // Trigger an IntegerDivisionByZeroException.
    ...
  });
});
--------------------------------------------------------------------------------

Here is the (truncated) test run output:

--------------------------------------------------------------------------------
unittest-suite-wait-for-done
setting up
tearing down

FAIL: tearDown behavior when test has error in it
  Caught IntegerDivisionByZeroException
  ...

0 PASSED, 1 FAILED, 0 ERRORS
Uncaught Error: Exception: Some tests failed.
Stack Trace:
...
--------------------------------------------------------------------------------

===== setUp() and tearDown() in nested group()s

The `setUp()` and `tearDown()` functions reset with the start of a new `group()`.
This applies to nested `group()`s, which do not inherit these functions:

--------------------------------------------------------------------------------
group('test Point with nested setUp()', () {
  Point point;
  setUp(() {  
    point = new Point(3, 4);
  });
  
  group('[]()', () {
    // setUp() from outer group() does not run here. point is null.
    test('with valid index', () => ... );
    test('with invalid index', () => ... );
  });
});
--------------------------------------------------------------------------------

You can fix this problem by assigning each nested `group()` its own `setUp()`
and `tearDown()`.


=== Testing synchronous exceptions

==== Problem

You want to test exceptions in your code. You want to know if some code
returns normally, or if it throws. Or, you want to test that a specific error is
raised, and that the error message is correct. 

==== Solution

To test whether code throws, use the `throws` matcher: 

--------------------------------------------------------------------------------
expect(() => 10 ~/ 0, throws);
--------------------------------------------------------------------------------

To test that code runs without generating an exception, use the
`returnsNormally` matcher:

--------------------------------------------------------------------------------
expect(() => 10 ~/ 1, returnsNormally);
--------------------------------------------------------------------------------
  
You can test the error type:

--------------------------------------------------------------------------------
expect(() => throw new StateError('functions called in the wrong order'), 
    throwsStateError);
--------------------------------------------------------------------------------

The Unittest library provides matchers for commonly occuring exceptions and
errors:

--------------------------------------------------------------------------------
throwsException
throwsFormatException
throwsArgumentError
throwsRangeError
throwsNoSuchMethodError
throwsUnimplementedError
throwsStateError
throwsUnsupportedError
--------------------------------------------------------------------------------

You can also use `throwsA` with a `predicate()` to test the exception type.
A `predicate()` returns a matcher using a function that returns true or
false:

--------------------------------------------------------------------------------
expect(() => 10 ~/ 0, 
  throwsA(predicate((e) => e is IntegerDivisionByZeroException)));
--------------------------------------------------------------------------------
  
You can test the error message:

--------------------------------------------------------------------------------
expect(() => throw new ArgumentError('bad argument'), 
  throwsA(predicate((e) => e.message == 'bad argument')));
--------------------------------------------------------------------------------

You can test the error type and the error message together:
  
--------------------------------------------------------------------------------
expect(() => throw new RangeError('out of range'), 
  throwsA(predicate((e) => (e is RangeError && e.message == 'out of range'))));
--------------------------------------------------------------------------------


=== Testing for double equality

==== Problem

Arithmetic involving doubles is inexact. You want to compare two doubles to
determine if they are acceptably close.

==== Solution 

Use the `closeTo()` matcher for testing approximate numerical equality:

--------------------------------------------------------------------------------
closeTo(value, delta)
--------------------------------------------------------------------------------

This matcher checks if the number under test is within delta of some value.

Consider this code that computes the distance between two points: 

--------------------------------------------------------------------------------
Point point1 = new Point(-2, -3);
Point point2 = new Point(-4, 4);

print(point1.distanceTo(point2)); // 7.280109889280518.  
--------------------------------------------------------------------------------

Here's how you can test for approximate equality:

--------------------------------------------------------------------------------
expect(point1.distanceTo(point2)), closeTo(7.28, .001)); 
--------------------------------------------------------------------------------



