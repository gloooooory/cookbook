= Dart Cookbook
:author: Shailen Tuli
:encoding: UTF-8

== Strings

=== Concatenating Strings

==== Problem

You want to concatenate strings in Dart. You tried using `+`, but that
resulted in an error.

==== Solution

Use adjacent string literals:

--------------------------------------------------
var fact = 'Dart'  'is' ' fun!'; // 'Dart is fun!'
--------------------------------------------------

==== Discussion

Adjacent literals also work over multiple lines:

-------------------------
var fact = 'Dart'
'is'
'fun!'; // 'Dart is fun!'
-------------------------

They also work when using multiline strings:

----------------------------------------
var lunch = '''Peanut
butter'''
'''and
jelly'''; // 'Peanut\nbutter and\njelly'
----------------------------------------

You can concatenate adjacent single line literals with multiline
strings:

--------------------------------------
var funnyGuys = 'Dewey ' 'Cheatem'
''' and
Howe'''; // 'Dewey Cheatem and\n Howe'
--------------------------------------

===== Alternatives to adjacent string literals

You can also use the `concat()` method on a string to concatenate it to
another string:

---------------------------------------------------
var film = filmToWatch();
film = film.concat('\n');  // 'The Big Lebowski\n' 
---------------------------------------------------

Since `concat()` creates a new string every time it is invoked, a long
chain of `concat()` s can be expensive. Avoid those. Use a StringBuffer
instead (see _Incrementally building a string efficiently using a
StringBuffer_, below).

Use can `join()` to combine a sequence of strings:

-----------------------------------------------------------------------
var film = ['The', 'Big', 'Lebowski']).join(' '); // 'The Big Lebowski'
-----------------------------------------------------------------------

You can also use string interpolation to concatenate strings (see
_Interpolating expressions inside strings_, below).

=== Interpolating expressions inside strings

==== Problem

You want to embed Dart code inside strings.

==== Solution

You can put the value of an expression inside a string by using
$\{expression}.

----------------------------------------------------------------------
var favFood = 'sushi';
var whatDoILove = 'I love ${favFood.toUpperCase()}'; // 'I love SUSHI'
----------------------------------------------------------------------

You can skip the \{} if the expression is an identifier:

------------------------------------------------------
var whatDoILove = 'I love $favFood'; // 'I love sushi'
  
------------------------------------------------------

==== Discussion

An interpolated string, `string ${expression}` is equivalent to the
concatenation of the strings 'string ' and `expression.toString()`.
Consider this code:

-----------------------------------------------------
var four = 4;
var seasons = 'The $four seasons'; // 'The 4 seasons'
-----------------------------------------------------

This is functionally equivalent to the following:

-------------------------------------------------------------
var seasons = 'The '.concat(4.toString()).concat(' seasons');
// 'The 4 seasons'
-------------------------------------------------------------

You should consider implementing a `toString()` method for user-defined
objects. Here's what happens if you don't:

-------------------------------------------------------
class Point {
  num x, y;
  Point(this.x, this.y);
}

var point = new Point(3, 4);
print('Point: $point'); // "Point: Instance of 'Point'"
-------------------------------------------------------

Probably not what you wanted. Here is the same example with an explicit
`toString()`:

----------------------------------------------
class Point {
  ...
    
  String toString() => 'x: $x, y: $y';
}

print('Point: $point'); // 'Point: x: 3, y: 4'
----------------------------------------------

=== Handling special characters within strings

==== Problem

You want to put newlines, dollar signs, or other special characters in
your strings.

==== Solution

Prefix special characters with a `\`.

------------------------
  print(Wile\nCoyote'); 
  // Wile
  // Coyote
------------------------

==== Discussion

Dart designates a few characters as special, and these can be escaped:

* \n for newline, equivalent to \x0A.
* \r for carriage return, equivalent to \x0D.
* \f for form feed, equivalent to \x0C.
* \b for backspace, equivalent to \x08.
* \t for tab, equivalent to \x09.
* \v for vertical tab, equivalent to \x0B.

If you prefer, you can use `\x` or `\u` notation to indicate the special
character:

-----------------------------------------------------------------
print('Wile\x0ACoyote');       // same as print('Wile\nCoyote'); 
print('Wile\u000ACoyote');     // same as print('Wile\nCoyote'); 
-----------------------------------------------------------------

You can also use `\u{}` notation:

---------------------------------------------------------------
print('Wile\u{000A}Coyote'); // same as print('Wile\nCoyote'); 
---------------------------------------------------------------

You can also escape the `$` used in string interpolation:

-------------------------------------------------------------------------
var superGenius = 'Wile Coyote';
print('$superGenius and Road Runner');  // 'Wile Coyote and Road Runner'
print('\$superGenius and Road Runner'); // '$superGenius and Road Runner'
-------------------------------------------------------------------------

If you escape a non-special character, the `\` is ignored:

-------------------------------------------
print('Wile \E Coyote'); // 'Wile E Coyote'
-------------------------------------------


=== Incrementally building a string efficiently using a StringBuffer

==== Problem

You want to collect string fragments and combine them in an efficient
manner.

==== Solution

Use a StringBuffer to programmatically generate a string. Consider this code
below, for assembling a series of urls from fragments:

--------------------------------------------------------------------------
var data = [{'scheme': 'https', 'domain': 'news.ycombinator.com'}, 
            {'domain': 'www.google.com'}, 
            {'domain': 'reddit.com', 'path': 'search', 'params': 'q=dart'}
           ];

String assembleUrlsUsingStringBuffer(entries) {
  StringBuffer sb = new StringBuffer();
  for (final item in entries) {
    sb.write(item['scheme'] != null ? item['scheme']  : 'http');
    sb.write("://");
    sb.write(item['domain']);
    sb.write('/');
    sb.write(item['path'] != null ? item['path']  : '');
    if (item['params'] != null) {
      sb.write('?');
      sb.write(item['params']);
    }
    sb.write('\n');
  }
  return sb.toString();
}

// https://news.ycombinator.com/
// http://www.google.com/
// http://reddit.com/search?q=dart
--------------------------------------------------------------------------

==== Discussion

A StringBuffer collects string fragments, but does not generate a new string
until `toString()` is called.  This is vastly more efficient than
concatenating fragments at each step: Consider this rewrite of the above code:

-------------------------------------------------------------------------
String assembleUrlsUsingConcat(entries) {
  var urls = '';
  for (final item in entries) {
    urls = urls.concat(item['scheme'] != null ? item['scheme']  : 'http');
    urls = urls.concat("://");
    urls = urls.concat(item['domain']);
    urls = urls.concat('/');
    urls = urls.concat(item['path'] != null ? item['path']  : '');
    if (item['params'] != null) {
      urls = urls.concat('?');
      urls = urls.concat(item['params']);
    }
    urls = urls.concat('\n');
  }
  return urls;
}
-------------------------------------------------------------------------

This approach produces the exact same result, but incurs the cost of
joining strings multiple times. 

Because a StringBuffer waits until the call to `toString()` to generate
the concatenated string, it represents a more efficient way of combining
strings than `concat()`. See the _Concatenating Strings_ recipe for a
description of `concat()`.

===== Other StringBuffer methods

In addition to `write()`, the StringBuffer class provides methods to
write a list of strings (`writeAll()`), write a numerical character code
(`writeCharCode()`), write with an added newline (`writeln()`), and
more. Here is a simple example that show the use of these methods:

-------------------------------------------------------------------------------
var sb = new StringBuffer();
sb.writeln('The Beatles:');
sb.writeAll(['John, ', 'Paul, ', 'George, and Ringo']);
sb.writeCharCode(33); // charCode for '!'.
var beatles = sb.toString(); // 'The Beatles:\nJohn, Paul, George, and Ringo!' 
-------------------------------------------------------------------------------

=== Determining if a string is empty

==== Problem

You want to know if a string is empty. You tried `if(string) {...}`, but
that did not work.

==== Solution

Use `string.isEmpty`:

----------------------------
var emptyString = '';
emptyString.isEmpty; // true
----------------------------

You can also just use `==`:

----------------------------------------
string == ""; // True if string is empty.
----------------------------------------

A string with a space is not empty:

-----------------------
var space = ' ';
space.isEmpty; // false
-----------------------

==== Discussion

Don't use `if (string)` to test the emptiness of a string. In Dart, all
objects except the boolean true evaluate to false. `if(string)` will
always be false. And you will see a warning in the editor if you use
an 'if' statement with a non-boolean in checked mode.


=== Removing leading and trailing whitespace

==== Problem

You want to remove leading and trailing whitespace from a string.

==== Solution

Use `string.trim()`:

----------------------------------------------------------------------
var space = '\n\r\f\t\v';  // We'll use a variety of space characters.
var string = '$space X $space';
var newString = string.trim(); // 'X'
----------------------------------------------------------------------

The String class has no methods to remove only leading or only trailing
whitespace. But you can always use regExps.

Remove only leading whitespace:

----------------------------------------------------------------------------
var newString = string.replaceFirst(new RegExp(r'^\s+'), ''); //  'X $space'
----------------------------------------------------------------------------

Remove only trailing whitespace:

---------------------------------------------------------------------------
var newString = string.replaceFirst(new RegExp(r'\s+$'), ''); // '$space X'
---------------------------------------------------------------------------


=== Changing string case

==== Problem

You want to change the case of strings.

==== Solution

Use `string.toUpperCase()` and `string.toLowerCase()` to convert a
string to lower-case or upper-case, respectively:

--------------------------------------------
var theOneILove = 'I love Lucy';
theOneILove.toUpperCase(); // 'I LOVE LUCY!'
theOneILove.toLowerCase(); // 'i love lucy!'
--------------------------------------------

==== Discussion

Case changes affect the characters of bi-cameral scripts like Greek and
French: var zeus = '039403af03b103c2'; // 'Δίας' (Zeus in modern Greek)
zeus.toUpperCase(); // 'ΔΊΑΣ'

-----------------------------------------------------------------------
var zeus = '\u0394\u03af\u03b1\u03c2'; // 'Δίας' (Zeus in modern Greek)
zeus.toUpperCase(); // 'ΔΊΑΣ'

var resume = '\u0052\u00e9\u0073\u0075\u006d\u00e9'; // 'Résumé'
resume.toLowerCase(); // 'résumé'
----------------------------------------------------------------

They do not affect the characters of uni-cameral scripts like Devanagari
(used for writing many of the languages of India):

------------------------------------------------------------------------
var chickenKebab = '\u091a\u093f\u0915\u0928 \u0915\u092c\u093e\u092c'; 
// 'चिकन कबाब'  (in Devanagari)
chickenKebab.toLowerCase();  // 'चिकन कबाब'
chickenKebab.toUpperCase();  // 'चिकन कबाब'
------------------------------------------------------------------------

If a character's case does not change when using `toUpperCase()` and
`toLowerCase()`, it is most likely because the character only has one
form.










=== Handling extended characters that are composed of multiple code units

==== Problem

You want to use emoticons and other special symbols that don't fit into 16
bits. How can you create such strings and use them effectively in your code? 

==== Solution

You can create an extended character using `'\u{}'` syntax:

-----------------------------
var clef = '\u{1F3BC}'; // 🎼
-----------------------------

You can mostly use this string like any other:

--------------------
print(clef); // '🎼 '
--------------------

Some special considerations apply when handling strings that are internally
composed to 2 strings. These are discussed below.

==== Discussion

'\u{1F3BC}' is composed of `'\uD83C'` and `'\uDFBC'`, the 'surrogate pair' of
the clef glyph. 

------------------------------------------------------------
clef.codeUnits.map((codeUnit) => codeUnit.toRadixString(16)); 
// ['d83c', 'dfbc']
------------------------------------------------------------

Using a surrogate pair is the normal way of encoding extended
Unicode characters. Most UTF-16 strings that you will ever encounter are
stored as two-byte (16 bit) code sequences. Since two bytes can only contain
the 65,536 characters in the 0x0 to 0xFFFF range, a pair of code points are
used to store values in the 0x10000 to 0x10FFFF range.

The clef glyph is composed of two code units, but only a single code point.
Borrowing terminology from Go, Dart uses the term `rune` for an integer
representing a Unicode code point. 

===== Getting the length of an extended string

String length is described in code units by default:

-----------------------------------------------------------
var clef = '\u{1F3BC}'; // 🎼

print(clef.length); // 2
print(clef.codeUnits.length); // 2
-----------------------------------------------------------

You can always query the `runes` getter to get the rune length:

-----------------------------------------------------------
print(clef.runes.length); // 1
print(clef.runes.map((rune) => rune.toRadixString(16)).toList()));
// ['1f3bc']
-----------------------------------------------------------

===== Subscripting an extended string

Subscripting a string that contains characters that are larger than 16 bits
requires special attention. This is because the default `[]` implementation
subscripts along code units. This means that for non-BMP characters,
subscripting yields invalid UTF-16 characters:

--------------------------------------------------------------
var teacup = '\u{1F375}'; // 🍵  
teacup[0]; // 55356
teacup.codeUnits.toList()[0]; // The same, 55356.
--------------------------------------------------------------

The number 55356 represents the first item of the surrogate pair that makes up
`teacup`. This represents an invalid string.

It is easy to end up with invalid strings when subscripting an extended
string inside a loop:

-------------------------------------------
var list = [];
for(var i = 0; i < clef.length; i++) {
  list.add([clef[i], clef[i].runes.first]); 
}
-------------------------------------------

Dart Editor show the value of `list` as `[[?, 55356], [?, 57276]]`. Because
`list` contains invalid strings, trying to print it generates an error.


When working with extended strings, it is better to subscript the runes:

--------------------------------------------------------------
teacup.runes.toList()[0]; // 127861
--------------------------------------------------------------

The number 127861 represents the code point for teacup, '\u{1F375}' (🍵 ).

===== Problems with using split('') with an extended string

Because `split('')` splits at the UTF-16 code unit boundaries, invoking it
on a non-BMP character yields the string's surrogate pair:

------------------------------------------
var clef = '\u{1F3BC}'; // 🎼 
clef.split('').length; // 2
------------------------------------------

The surrogate pair members are not valid UTF-16 strings.

Map the string runes instead:

---------------------------------------------------------------------------
var clef = '\u{1F3BC}'; // 🎼 
var title = '$clef list:'
print(subject.runes.map((rune) => new String.fromCharCode(rune)).toList());
// ['🎼', ' ', 'l', 'i', 's', 't', ':']
--------------------------------------------------------------------------











=== Converting between string characters and numerical codes

==== Problem

You want to convert string characters into numerical codes and back. You want
to do this because sometimes you need to compare characters in a string to
numerical values coming from another source. Or, maybe you want to split up
a string into individual characters and operate on each character.

==== Solution

Use the `runes` getter to access a string's code points:

--------------------------------------------
'Dart'.runes.toList(); // [68, 97, 114, 116]

var smileyFace = '\u263A'; // ☺
smileyFace.runes.toList(); // [9786]
--------------------------------------------

The number 9786 represents the code unit '263A'.

Use `string.codeUnits` to get a string's UTF-16 code units:

------------------------------------------------
'Dart'.codeUnits.toList(); // [68, 97, 114, 116]
smileyFace.codeUnits.toList(); // [9786]
------------------------------------------------

==== Discussion

For most strings, using `runes` or `codeUnits` produces identical results.
This is not the case for extended characters:

------------------------------------------
var clef = '\u{1F3BC}'; // 🎼 
clef.codeUnits.toList(); // [55356, 57276]
clef.runes.toList(); // [127932]
------------------------------------------

===== Using codeUnitAt() to access individual code units

To access the code unit at a particular index, use `codeUnitAt()`:

---------------------------------
'Dart'.codeUnitAt(0); // 68
smileyFace.codeUnitAt(0); // 9786
---------------------------------

Using `codeUnitAt()` with an extended character yields an invalid
string. 

// [[ xref ]]

==== Converting numerical codes to strings

You can generate a new string from numerical codes using the factory
`String.fromCharCodes(charCodes)`. You can pass either runes or code
units and it can tell the difference and do the right thing
automatically:

---------------------------------------------------------------
new String.fromCharCodes([68, 97, 114, 116]); // 'Dart'

new String.fromCharCodes([73, 32, 9825, 32, 76, 117, 99, 121]);
// 'I ♡ Lucy'

// Passing code units representing the surrogate pair.
new String.fromCharCodes([55356, 57276]); // 🎼  


// Passing runes.
new String.fromCharCodes([127932]), // 🎼  
---------------------------------------------------------------

You can use the `String.fromCharCode()` factory to convert a single rune
or code unit to a string:

---------------------------------------
new String.fromCharCode(68); // 'D'
new String.fromCharCode(9786); // ☺
new String.fromCharCode(127932); // 🎼  
---------------------------------------

Creating a string with only one half of a surrogate pair is permitted,
but not recommended.


=== Calculating the length of a string

==== Problem

You want to get the length of a string, but are not sure how to
correctly calculate the length when working with Unicode.

==== Solution

Use `string.length` to get the number of UTF-16 code units in a string:

----------------------------------
'I love music'.length; // 12
'I love music'.runes.length; // 12
----------------------------------

==== Discussion

For extended characters, the rune length will be less than the code
unit length:

------------------------------------------
var clef = '\u{1F3BC}'; // 🎼  
var subject = '$clef list:';

clef.length; // 2
clef.runes.length; // 1

var music = 'I $hearts $clef'; // 'I ♡ 🎼 '
music.length; // 6
music.runes.length // 5
------------------------------------------

Use `length` if you want to number of code units; use `runes.length` if
you want the number of runes.

// [[ xref ]]

===== Working with combined characters

It is tempting to brush aside much of the complexity involved in dealing with
runes and code units and base the length of the string on the number of
characters it appears to have. Anyone can tell that 'Dart' has four characters,
and 'Amelié' has six, right? Almost. The length of 'Dart' is indeed four, but
the length of 'Amelié' depends on how that string was constructed:

---------------------------------------------------
var name = 'Ameli\u00E9';  // 'Amelié'
var anotherName = 'Ameli\u0065\u0301';  // 'Amelié'
print(name.length); // 6
print(anotherName.length); // 7
---------------------------------------------------

Both `name` and `anotherName` return strings that look the same, but where
the 'é' is constructed using a different number of runes. This makes it
impossible to know the length of these strings by intuitive visual inspection. 


=== Processing a string one character at a time

==== Problem

You want to do something with each individual character in a string.

==== Solution


For most strings, you can map the results of calling string.split(''):

----------------------------------------------------------
var lang= 'Dart';
print(lang.split('').map((char) => '*${char}*').toList());
// ['*D*', '*a*', '*r*', '*t*']
----------------------------------------------------------


==== Discussion

Splitting on an empty string works fine for 16-bit non-ascii strings:

---------------------------------------------------------
var smileyFace = '\u263A';
var happy = 'I am $smileyFace';
print(happy.split('')); // ['I', ' ', 'a', 'm', ' ', '☺']
---------------------------------------------------------

You can also map the string runes:

------------------------------------------------------------------------
var charList = "Dart".runes.map((rune) {
  return '*${new String.fromCharCode(rune)}*').toList();
});
// ['*D*', '*a*', '*r*', '*t*']

var runeList = happy.runes.map((rune) {
  return [rune, new String.fromCharCode(rune)]).toList();
});
// [[73, 'I'], [32, ' '], [97, 'a'], [109, 'm'], [32, ' '], [9786, '☺']]
------------------------------------------------------------------------

For extended strings that don't fit within 16 bits, you must map the string
runes.

// [[ xref ]]

===== Looping over strings

You can loop over the characters of a string, and process each unit. This will
mostly work fine:
        
var list = [];
for(var i = 0; i < lang.length; i++) {
  list.add('*${lang[i]}*'); 
}

print(list); // ['*D*', '*a*', '*r*', '*t*']


=== Splitting a string into substrings using a delimiter or a pattern

==== Problem

You want to split a string into substrings.

==== Solution

Use the `split()` method with a string or a regExp as an argument.

-------------------------------------
var smileyFace = '\u263A';
var happy = 'I am $smileyFace';
happy.split(' '); // ['I', 'am', '☺']
-------------------------------------

Here is an example of using `split()` with a regExp:

--------------------------------------------------------------
var nums = '2/7 3 4/5 3~/5';
var numsRegExp = new RegExp(r'(\s|/|~/)');
nums.split(numsRegExp); // ['2', '7', '3', '4', '5', '3', '5']
--------------------------------------------------------------

In the code above, the string `nums` contains various numbers, some of
which are expressed as fractions or as int-divisions. A regExp is used
to split the string to extract just the numbers.

You can perform operations on the matched and unmatched portions of a
string when using `split()` with a regExp:

----------------------------------------------------------------
'Eats SHOOTS leaves'.splitMapJoin((new RegExp(r'SHOOTS')),
  onMatch: (m) => '*${m.group(0).toLowerCase()}*',
  onNonMatch: (n) => n.toUpperCase()); // 'EATS *shoots* LEAVES'
  
----------------------------------------------------------------

The regExp matches the middle word ('SHOOTS'). A pair of callbacks are
registered to transform the matched and unmatched substrings before the
substrings are joined together again.

=== Determining whether a string contains another string

==== Problem

You want to find out if a string is the substring of another string.

==== Solution

Use `string.contains()`:

----------------------------------------
var fact = 'Dart strings are immutable';
string.contains('immutable'); // True.
----------------------------------------

You can indicate a startIndex as a second argument:

------------------------------------
string.contains('Dart', 2); // False
------------------------------------

==== Discussion

The String library provides a couple of shortcuts for testing whether a
string is a substring of another:

-----------------------------------
string.startsWith('Dart'); // True.
string.endsWith('e'); // True.
-----------------------------------

You can also use `string.indexOf()`, which returns -1 if the substring
is not found within a string, and its matching index, if it is:

--------------------------------------------------------------
string.indexOf('art') != -1; // True, `art` is found in `Dart`
--------------------------------------------------------------

You can also use a regExp and `hasMatch()`:

------------------------------------------------------------------------
new RegExp(r'ar[et]').hasMatch(string); //  True, 'art' and 'are' match.
------------------------------------------------------------------------

=== Finding matches of a regExp pattern in a string

==== Problem

You want to use regExp to match a pattern in a string, and want to be
able to access the matches.

==== Solution

Construct a regular expression using the RegExp class and find matches
using the `allMatches()` method:

------------------------------------------------------------------
var neverEatingThat = 'Not with a fox, not in a box';
var regExp = new RegExp(r'[fb]ox');
List matches = regExp.allMatches(neverEatingThat);
matches.map((match) => match.group(0)).toList(); // ['fox', 'box']
------------------------------------------------------------------

==== Discussion

You can query the object returned by `allMatches()` to find out the
number of matches:

--------------------
matches.length; // 2
--------------------

To find the first match, use `firstMatch()`:

-----------------------------------------------------
regExp.firstMatch(neverEatingThat).group(0); // 'fox'
-----------------------------------------------------

To directly access the matched string, use `stringMatch()`:

----------------------------------------------------
regExp.stringMatch(neverEatingThat); // 'fox'
regExp.stringMatch('I like bagels and lox'); // null
----------------------------------------------------

=== Substituting strings based on regExp matches

==== Problem

You want to match substrings within a string and make substitutions
based on the matches.

==== Solution

Construct a regular expression using the RegExp class and make
replacements using `replaceAll()` method:

------------------------------------------------------------
'resume'.replaceAll(new RegExp(r'e'), '\u00E9'); // 'résumé'
------------------------------------------------------------

If you want to replace just the first match, use 'replaceFirst()`:

--------------------------------------------------------
'0.0001'.replaceFirst(new RegExp(r'0+'), ''); // '.0001'
--------------------------------------------------------

The RegExp matches for one or more 0's and replaces them with an empty
string.

You can use `replaceAllMatched()` and register a function to modify the
matches:

--------------------------------------------------------------------------
var heart = '\u2661'; // '♡'
var string = 'I like Ike but I $heart Lucy';
var regExp = new RegExp(r'[A-Z]\w+');
string.replaceAllMapped(regExp, (match) => match.group(0).toUpperCase()); 
// 'I like IKE but I ♡ LUCY'
--------------------------------------------------------------------------
